<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>graph: graph::DigraphMap&lt; VertKey, VertVal, EdgeKey, EdgeVal, Map &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">graph
   </div>
   <div id="projectbrief">A simple, header-only C++ directed graph library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>graph</b></li><li class="navelem"><a class="el" href="structgraph_1_1_digraph_map.html">DigraphMap</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="structgraph_1_1_digraph_map-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">graph::DigraphMap&lt; VertKey, VertVal, EdgeKey, EdgeVal, Map &gt; Struct Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A digraph class that allows vertices and/or edges to be indexed by a custom type in O(1) time.  
 <a href="structgraph_1_1_digraph_map.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="digraph__map_8h_source.html">digraph_map.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for graph::DigraphMap&lt; VertKey, VertVal, EdgeKey, EdgeVal, Map &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="structgraph_1_1_digraph_map.png" usemap="#graph::DigraphMap_3C_20VertKey_2C_20VertVal_2C_20EdgeKey_2C_20EdgeVal_2C_20Map_20_3E_map" alt=""/>
  <map id="graph::DigraphMap_3C_20VertKey_2C_20VertVal_2C_20EdgeKey_2C_20EdgeVal_2C_20Map_20_3E_map" name="graph::DigraphMap_3C_20VertKey_2C_20VertVal_2C_20EdgeKey_2C_20EdgeVal_2C_20Map_20_3E_map">
<area href="structgraph_1_1_digraph.html" title="A class representing a directed graph." alt="graph::Digraph&lt; V, E, Map &gt;" shape="rect" coords="0,0,394,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7e1adadbe5507bb6883c1a222b42e6fd"><td class="memItemLeft" align="right" valign="top"><a id="a7e1adadbe5507bb6883c1a222b42e6fd" name="a7e1adadbe5507bb6883c1a222b42e6fd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>vertex_iterator</b> = <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">VertexIterator</a>&lt; Constness::Mutable &gt;</td></tr>
<tr class="separator:a7e1adadbe5507bb6883c1a222b42e6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c1f69a8162fb57ed1a67ddfe1d61a3"><td class="memItemLeft" align="right" valign="top"><a id="ab4c1f69a8162fb57ed1a67ddfe1d61a3" name="ab4c1f69a8162fb57ed1a67ddfe1d61a3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_vertex_iterator</b> = <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">VertexIterator</a>&lt; Constness::Const &gt;</td></tr>
<tr class="separator:ab4c1f69a8162fb57ed1a67ddfe1d61a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fcf928b1091dfd6a7b38ce3767fcaaa"><td class="memItemLeft" align="right" valign="top"><a id="a8fcf928b1091dfd6a7b38ce3767fcaaa" name="a8fcf928b1091dfd6a7b38ce3767fcaaa"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>edge_iterator</b> = <a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">EdgeIterator</a>&lt; Constness::Mutable &gt;</td></tr>
<tr class="separator:a8fcf928b1091dfd6a7b38ce3767fcaaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe168f294b8bcbfac4681350771beb83"><td class="memItemLeft" align="right" valign="top"><a id="abe168f294b8bcbfac4681350771beb83" name="abe168f294b8bcbfac4681350771beb83"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_edge_iterator</b> = <a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">EdgeIterator</a>&lt; Constness::Const &gt;</td></tr>
<tr class="separator:abe168f294b8bcbfac4681350771beb83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a502601c837cd50a57475d7170c0dfad1"><td class="memItemLeft" align="right" valign="top"><a id="a502601c837cd50a57475d7170c0dfad1" name="a502601c837cd50a57475d7170c0dfad1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>incident_edge_iterator</b> = <a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">IncidentEdgeIterator</a>&lt; Constness::Mutable &gt;</td></tr>
<tr class="separator:a502601c837cd50a57475d7170c0dfad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96e6fa371b27a1e6599f5389e19b8a0"><td class="memItemLeft" align="right" valign="top"><a id="ac96e6fa371b27a1e6599f5389e19b8a0" name="ac96e6fa371b27a1e6599f5389e19b8a0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_incident_edge_iterator</b> = <a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">IncidentEdgeIterator</a>&lt; Constness::Const &gt;</td></tr>
<tr class="separator:ac96e6fa371b27a1e6599f5389e19b8a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4539705f7b79273ea3681f7f8bf6b1"><td class="memItemLeft" align="right" valign="top"><a id="a4e4539705f7b79273ea3681f7f8bf6b1" name="a4e4539705f7b79273ea3681f7f8bf6b1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>vertex_ref</b> = <a class="el" href="structgraph_1_1_digraph_1_1_vertex_ref.html">VertexRef</a>&lt; Constness::Mutable &gt;</td></tr>
<tr class="separator:a4e4539705f7b79273ea3681f7f8bf6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930b150bd3641193d94d88045726a11f"><td class="memItemLeft" align="right" valign="top"><a id="a930b150bd3641193d94d88045726a11f" name="a930b150bd3641193d94d88045726a11f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_vertex_ref</b> = <a class="el" href="structgraph_1_1_digraph_1_1_vertex_ref.html">VertexRef</a>&lt; Constness::Const &gt;</td></tr>
<tr class="separator:a930b150bd3641193d94d88045726a11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12fb580792550f7ae911bc808e94a256"><td class="memItemLeft" align="right" valign="top"><a id="a12fb580792550f7ae911bc808e94a256" name="a12fb580792550f7ae911bc808e94a256"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>edge_ref</b> = <a class="el" href="structgraph_1_1_digraph_1_1_edge_ref.html">EdgeRef</a>&lt; Constness::Mutable &gt;</td></tr>
<tr class="separator:a12fb580792550f7ae911bc808e94a256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985959e1242e88857f3d47a5cf8c2f35"><td class="memItemLeft" align="right" valign="top"><a id="a985959e1242e88857f3d47a5cf8c2f35" name="a985959e1242e88857f3d47a5cf8c2f35"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_edge_ref</b> = <a class="el" href="structgraph_1_1_digraph_1_1_edge_ref.html">EdgeRef</a>&lt; Constness::Const &gt;</td></tr>
<tr class="separator:a985959e1242e88857f3d47a5cf8c2f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_structgraph_1_1_digraph"><td colspan="2" onclick="javascript:toggleInherit('pub_types_structgraph_1_1_digraph')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="structgraph_1_1_digraph.html">graph::Digraph&lt; V, E, Map &gt;</a></td></tr>
<tr class="memitem:a7e1adadbe5507bb6883c1a222b42e6fd inherit pub_types_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="a7e1adadbe5507bb6883c1a222b42e6fd" name="a7e1adadbe5507bb6883c1a222b42e6fd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>vertex_iterator</b> = <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">VertexIterator</a>&lt; Constness::Mutable &gt;</td></tr>
<tr class="separator:a7e1adadbe5507bb6883c1a222b42e6fd inherit pub_types_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c1f69a8162fb57ed1a67ddfe1d61a3 inherit pub_types_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="ab4c1f69a8162fb57ed1a67ddfe1d61a3" name="ab4c1f69a8162fb57ed1a67ddfe1d61a3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_vertex_iterator</b> = <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">VertexIterator</a>&lt; Constness::Const &gt;</td></tr>
<tr class="separator:ab4c1f69a8162fb57ed1a67ddfe1d61a3 inherit pub_types_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fcf928b1091dfd6a7b38ce3767fcaaa inherit pub_types_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="a8fcf928b1091dfd6a7b38ce3767fcaaa" name="a8fcf928b1091dfd6a7b38ce3767fcaaa"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>edge_iterator</b> = <a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">EdgeIterator</a>&lt; Constness::Mutable &gt;</td></tr>
<tr class="separator:a8fcf928b1091dfd6a7b38ce3767fcaaa inherit pub_types_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe168f294b8bcbfac4681350771beb83 inherit pub_types_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="abe168f294b8bcbfac4681350771beb83" name="abe168f294b8bcbfac4681350771beb83"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_edge_iterator</b> = <a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">EdgeIterator</a>&lt; Constness::Const &gt;</td></tr>
<tr class="separator:abe168f294b8bcbfac4681350771beb83 inherit pub_types_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a502601c837cd50a57475d7170c0dfad1 inherit pub_types_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="a502601c837cd50a57475d7170c0dfad1" name="a502601c837cd50a57475d7170c0dfad1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>incident_edge_iterator</b> = <a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">IncidentEdgeIterator</a>&lt; Constness::Mutable &gt;</td></tr>
<tr class="separator:a502601c837cd50a57475d7170c0dfad1 inherit pub_types_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96e6fa371b27a1e6599f5389e19b8a0 inherit pub_types_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="ac96e6fa371b27a1e6599f5389e19b8a0" name="ac96e6fa371b27a1e6599f5389e19b8a0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_incident_edge_iterator</b> = <a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">IncidentEdgeIterator</a>&lt; Constness::Const &gt;</td></tr>
<tr class="separator:ac96e6fa371b27a1e6599f5389e19b8a0 inherit pub_types_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7544512439f6b7d32b8117f8716469a0 inherit pub_types_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="a7544512439f6b7d32b8117f8716469a0" name="a7544512439f6b7d32b8117f8716469a0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>vertex_range</b> = <a class="el" href="structgraph_1_1_digraph_1_1_vertex_range.html">VertexRange</a>&lt; Constness::Mutable &gt;</td></tr>
<tr class="separator:a7544512439f6b7d32b8117f8716469a0 inherit pub_types_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c85c6c68327a7fa2c44401373394734 inherit pub_types_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="a4c85c6c68327a7fa2c44401373394734" name="a4c85c6c68327a7fa2c44401373394734"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_vertex_range</b> = <a class="el" href="structgraph_1_1_digraph_1_1_vertex_range.html">VertexRange</a>&lt; Constness::Const &gt;</td></tr>
<tr class="separator:a4c85c6c68327a7fa2c44401373394734 inherit pub_types_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af000f14c0cc10487971110555684246d inherit pub_types_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="af000f14c0cc10487971110555684246d" name="af000f14c0cc10487971110555684246d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>edge_range</b> = <a class="el" href="structgraph_1_1_digraph_1_1_edge_range.html">EdgeRange</a>&lt; Constness::Mutable &gt;</td></tr>
<tr class="separator:af000f14c0cc10487971110555684246d inherit pub_types_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6724bca2ecc2f4f0d04fbf74dbb88bc7 inherit pub_types_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="a6724bca2ecc2f4f0d04fbf74dbb88bc7" name="a6724bca2ecc2f4f0d04fbf74dbb88bc7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_edge_range</b> = <a class="el" href="structgraph_1_1_digraph_1_1_edge_range.html">EdgeRange</a>&lt; Constness::Const &gt;</td></tr>
<tr class="separator:a6724bca2ecc2f4f0d04fbf74dbb88bc7 inherit pub_types_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ac2dc037a7130aea427e86bd3fb0bc inherit pub_types_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="a88ac2dc037a7130aea427e86bd3fb0bc" name="a88ac2dc037a7130aea427e86bd3fb0bc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>incident_edge_range</b> = <a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_range.html">IncidentEdgeRange</a>&lt; Constness::Mutable &gt;</td></tr>
<tr class="separator:a88ac2dc037a7130aea427e86bd3fb0bc inherit pub_types_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616b4f18681cd5da578c121c4bd7d189 inherit pub_types_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="a616b4f18681cd5da578c121c4bd7d189" name="a616b4f18681cd5da578c121c4bd7d189"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_incident_edge_range</b> = <a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_range.html">IncidentEdgeRange</a>&lt; Constness::Const &gt;</td></tr>
<tr class="separator:a616b4f18681cd5da578c121c4bd7d189 inherit pub_types_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4539705f7b79273ea3681f7f8bf6b1 inherit pub_types_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="a4e4539705f7b79273ea3681f7f8bf6b1" name="a4e4539705f7b79273ea3681f7f8bf6b1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>vertex_ref</b> = <a class="el" href="structgraph_1_1_digraph_1_1_vertex_ref.html">VertexRef</a>&lt; Constness::Mutable &gt;</td></tr>
<tr class="separator:a4e4539705f7b79273ea3681f7f8bf6b1 inherit pub_types_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930b150bd3641193d94d88045726a11f inherit pub_types_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="a930b150bd3641193d94d88045726a11f" name="a930b150bd3641193d94d88045726a11f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_vertex_ref</b> = <a class="el" href="structgraph_1_1_digraph_1_1_vertex_ref.html">VertexRef</a>&lt; Constness::Const &gt;</td></tr>
<tr class="separator:a930b150bd3641193d94d88045726a11f inherit pub_types_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12fb580792550f7ae911bc808e94a256 inherit pub_types_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="a12fb580792550f7ae911bc808e94a256" name="a12fb580792550f7ae911bc808e94a256"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>edge_ref</b> = <a class="el" href="structgraph_1_1_digraph_1_1_edge_ref.html">EdgeRef</a>&lt; Constness::Mutable &gt;</td></tr>
<tr class="separator:a12fb580792550f7ae911bc808e94a256 inherit pub_types_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985959e1242e88857f3d47a5cf8c2f35 inherit pub_types_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="a985959e1242e88857f3d47a5cf8c2f35" name="a985959e1242e88857f3d47a5cf8c2f35"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_edge_ref</b> = <a class="el" href="structgraph_1_1_digraph_1_1_edge_ref.html">EdgeRef</a>&lt; Constness::Const &gt;</td></tr>
<tr class="separator:a985959e1242e88857f3d47a5cf8c2f35 inherit pub_types_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a99a9050535e715622bdfbb1b3f103232"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_ref.html">const_vertex_ref</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_map.html#a99a9050535e715622bdfbb1b3f103232">operator[]</a> (const VertKey &amp;key) const</td></tr>
<tr class="memdesc:a99a9050535e715622bdfbb1b3f103232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the vertex with the given key.  <br /></td></tr>
<tr class="separator:a99a9050535e715622bdfbb1b3f103232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2530573805615e994757ae920e1d54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_ref.html">vertex_ref</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_map.html#acb2530573805615e994757ae920e1d54">operator[]</a> (const VertKey &amp;key)</td></tr>
<tr class="memdesc:acb2530573805615e994757ae920e1d54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the vertex with the given key.  <br /></td></tr>
<tr class="separator:acb2530573805615e994757ae920e1d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5b4a65b2dcddb5cfb548b9335050c5"><td class="memItemLeft" align="right" valign="top"><a id="a7d5b4a65b2dcddb5cfb548b9335050c5" name="a7d5b4a65b2dcddb5cfb548b9335050c5"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_vertex_ref.html">vertex_ref</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (VertexId v)</td></tr>
<tr class="memdesc:a7d5b4a65b2dcddb5cfb548b9335050c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the vertex with the given Id. <br /></td></tr>
<tr class="separator:a7d5b4a65b2dcddb5cfb548b9335050c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b923977d404a9cf9e9782300487a47"><td class="memItemLeft" align="right" valign="top"><a id="ac5b923977d404a9cf9e9782300487a47" name="ac5b923977d404a9cf9e9782300487a47"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_vertex_ref.html">const_vertex_ref</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (VertexId v) const</td></tr>
<tr class="memdesc:ac5b923977d404a9cf9e9782300487a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the vertex with the given Id. <br /></td></tr>
<tr class="separator:ac5b923977d404a9cf9e9782300487a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e5459342f2d747a6af42fbdd5114dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_edge_ref.html">const_edge_ref</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_map.html#a56e5459342f2d747a6af42fbdd5114dc">operator[]</a> (const EdgeKey &amp;key) const</td></tr>
<tr class="memdesc:a56e5459342f2d747a6af42fbdd5114dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the edge with the given key.  <br /></td></tr>
<tr class="separator:a56e5459342f2d747a6af42fbdd5114dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca82b75251516cc0eb79e45b9151da63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_edge_ref.html">edge_ref</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_map.html#aca82b75251516cc0eb79e45b9151da63">operator[]</a> (const EdgeKey &amp;key)</td></tr>
<tr class="memdesc:aca82b75251516cc0eb79e45b9151da63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the edge with the given key.  <br /></td></tr>
<tr class="separator:aca82b75251516cc0eb79e45b9151da63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb56db8814020ad8930e56adc520560"><td class="memItemLeft" align="right" valign="top"><a id="acdb56db8814020ad8930e56adc520560" name="acdb56db8814020ad8930e56adc520560"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_edge_ref.html">edge_ref</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (EdgeId e)</td></tr>
<tr class="memdesc:acdb56db8814020ad8930e56adc520560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the edge with the given Id. <br /></td></tr>
<tr class="separator:acdb56db8814020ad8930e56adc520560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2721630675f865298615f6e30e9db0dd"><td class="memItemLeft" align="right" valign="top"><a id="a2721630675f865298615f6e30e9db0dd" name="a2721630675f865298615f6e30e9db0dd"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_edge_ref.html">const_edge_ref</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (EdgeId e) const</td></tr>
<tr class="memdesc:a2721630675f865298615f6e30e9db0dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the edge with the given Id. <br /></td></tr>
<tr class="separator:a2721630675f865298615f6e30e9db0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65b39da5436dff285ac5fc1af5c99df"><td class="memItemLeft" align="right" valign="top"><a id="ab65b39da5436dff285ac5fc1af5c99df" name="ab65b39da5436dff285ac5fc1af5c99df"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>contains</b> (const VertKey &amp;key) const</td></tr>
<tr class="memdesc:ab65b39da5436dff285ac5fc1af5c99df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a vertex with the given key is present in the graph. <br /></td></tr>
<tr class="separator:ab65b39da5436dff285ac5fc1af5c99df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b44b47361617651816891fb981ff3a"><td class="memItemLeft" align="right" valign="top"><a id="af1b44b47361617651816891fb981ff3a" name="af1b44b47361617651816891fb981ff3a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>contains</b> (const EdgeKey &amp;key) const</td></tr>
<tr class="memdesc:af1b44b47361617651816891fb981ff3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if an edge with the given key is present in the graph. <br /></td></tr>
<tr class="separator:af1b44b47361617651816891fb981ff3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fdc45156388185a02feac132d74c1f1"><td class="memItemLeft" align="right" valign="top">const VertKey &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_map.html#a3fdc45156388185a02feac132d74c1f1">key_for</a> (VertexId v) const</td></tr>
<tr class="memdesc:a3fdc45156388185a02feac132d74c1f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the key for the vertex with the given Id.  <br /></td></tr>
<tr class="separator:a3fdc45156388185a02feac132d74c1f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a518c5c74898607db589dd06771783dd6"><td class="memItemLeft" align="right" valign="top">const EdgeKey &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_map.html#a518c5c74898607db589dd06771783dd6">key_for</a> (EdgeId e) const</td></tr>
<tr class="memdesc:a518c5c74898607db589dd06771783dd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the key for the edge with the given Id.  <br /></td></tr>
<tr class="separator:a518c5c74898607db589dd06771783dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f57037d24892bf7ec4d881f9f7925d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_map.html#a9f57037d24892bf7ec4d881f9f7925d5">find_vertex</a> (const VertKey &amp;key)</td></tr>
<tr class="memdesc:a9f57037d24892bf7ec4d881f9f7925d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the vertex with the given key.  <br /></td></tr>
<tr class="separator:a9f57037d24892bf7ec4d881f9f7925d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dde2cb54cfc31f9bc9dcca0453bf7d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">const_vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_map.html#a7dde2cb54cfc31f9bc9dcca0453bf7d9">find_vertex</a> (const VertKey &amp;key) const</td></tr>
<tr class="memdesc:a7dde2cb54cfc31f9bc9dcca0453bf7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the vertex with the given key.  <br /></td></tr>
<tr class="separator:a7dde2cb54cfc31f9bc9dcca0453bf7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d6ec1e440386100c4d6b45ac8d3f2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_map.html#a91d6ec1e440386100c4d6b45ac8d3f2c">find_edge</a> (const EdgeKey &amp;key)</td></tr>
<tr class="memdesc:a91d6ec1e440386100c4d6b45ac8d3f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the edge with the given key.  <br /></td></tr>
<tr class="separator:a91d6ec1e440386100c4d6b45ac8d3f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb586e07f97607424b008498df8397d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">const_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_map.html#a5cb586e07f97607424b008498df8397d">find_edge</a> (const EdgeKey &amp;key) const</td></tr>
<tr class="memdesc:a5cb586e07f97607424b008498df8397d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the edge with the given key.  <br /></td></tr>
<tr class="separator:a5cb586e07f97607424b008498df8397d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72942f1ace36e9f968acfb0744805856"><td class="memItemLeft" align="right" valign="top"><a id="a72942f1ace36e9f968acfb0744805856" name="a72942f1ace36e9f968acfb0744805856"></a>
std::optional&lt; <a class="el" href="structgraph_1_1_digraph_1_1_vertex_ref.html">vertex_ref</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>vertex</b> (const VertKey &amp;key)</td></tr>
<tr class="memdesc:a72942f1ace36e9f968acfb0744805856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the vertex with the given key, or <code>std::nullopt</code> if not found. <br /></td></tr>
<tr class="separator:a72942f1ace36e9f968acfb0744805856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5820206eaab128abb7ce31bdac4a51fb"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structgraph_1_1_digraph_1_1_vertex_ref.html">const_vertex_ref</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_map.html#a5820206eaab128abb7ce31bdac4a51fb">vertex</a> (const VertKey &amp;key) const</td></tr>
<tr class="separator:a5820206eaab128abb7ce31bdac4a51fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6baa46dfd4a24aefa673d31df72d3c8"><td class="memItemLeft" align="right" valign="top"><a id="ab6baa46dfd4a24aefa673d31df72d3c8" name="ab6baa46dfd4a24aefa673d31df72d3c8"></a>
std::optional&lt; <a class="el" href="structgraph_1_1_digraph_1_1_edge_ref.html">edge_ref</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>edge</b> (const EdgeKey &amp;key)</td></tr>
<tr class="memdesc:ab6baa46dfd4a24aefa673d31df72d3c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the edge with the given key, or <code>std::nullopt</code> if not found. <br /></td></tr>
<tr class="separator:ab6baa46dfd4a24aefa673d31df72d3c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729b388524bdbeef3e1316fdfdea304a"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structgraph_1_1_digraph_1_1_edge_ref.html">const_edge_ref</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_map.html#a729b388524bdbeef3e1316fdfdea304a">edge</a> (const EdgeKey &amp;key) const</td></tr>
<tr class="separator:a729b388524bdbeef3e1316fdfdea304a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0527acc39fdda480a70dcbf704561851"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_map.html#a0527acc39fdda480a70dcbf704561851">erase</a> (const VertKey &amp;key)</td></tr>
<tr class="memdesc:a0527acc39fdda480a70dcbf704561851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the vertex with the given key from the graph, if present.  <br /></td></tr>
<tr class="separator:a0527acc39fdda480a70dcbf704561851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab233861ac2bedfdc9ffc6edd6498b1c4"><td class="memItemLeft" align="right" valign="top"><a id="ab233861ac2bedfdc9ffc6edd6498b1c4" name="ab233861ac2bedfdc9ffc6edd6498b1c4"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (<a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> vert)</td></tr>
<tr class="separator:ab233861ac2bedfdc9ffc6edd6498b1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25150490298a7314937d994e2b2cdd3"><td class="memItemLeft" align="right" valign="top"><a id="ac25150490298a7314937d994e2b2cdd3" name="ac25150490298a7314937d994e2b2cdd3"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (VertexId vert)</td></tr>
<tr class="separator:ac25150490298a7314937d994e2b2cdd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3899584e92bfcc6d8f782c9311ec18"><td class="memItemLeft" align="right" valign="top">std::optional&lt; EdgeVal &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_map.html#abc3899584e92bfcc6d8f782c9311ec18">erase</a> (const EdgeKey &amp;key)</td></tr>
<tr class="memdesc:abc3899584e92bfcc6d8f782c9311ec18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the edge with the given key from the graph, if present.  <br /></td></tr>
<tr class="separator:abc3899584e92bfcc6d8f782c9311ec18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523087655f421ac9f15b90473bee924f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_map.html#a523087655f421ac9f15b90473bee924f">erase</a> (const EdgeKey &amp;key)</td></tr>
<tr class="memdesc:a523087655f421ac9f15b90473bee924f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the edge with the given key from the graph, if present.  <br /></td></tr>
<tr class="separator:a523087655f421ac9f15b90473bee924f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5312f6d82b4773942c47c4897778b50"><td class="memItemLeft" align="right" valign="top"><a id="af5312f6d82b4773942c47c4897778b50" name="af5312f6d82b4773942c47c4897778b50"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (<a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">edge_iterator</a> <a class="el" href="structgraph_1_1_digraph_map.html#ab6baa46dfd4a24aefa673d31df72d3c8">edge</a>)</td></tr>
<tr class="memdesc:af5312f6d82b4773942c47c4897778b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the given edge from the graph. <br /></td></tr>
<tr class="separator:af5312f6d82b4773942c47c4897778b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2dde39243a8dab580115c16a1e15b1"><td class="memItemLeft" align="right" valign="top"><a id="a1d2dde39243a8dab580115c16a1e15b1" name="a1d2dde39243a8dab580115c16a1e15b1"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (EdgeId <a class="el" href="structgraph_1_1_digraph_map.html#ab6baa46dfd4a24aefa673d31df72d3c8">edge</a>)</td></tr>
<tr class="memdesc:a1d2dde39243a8dab580115c16a1e15b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the edge with the given ID from the graph. <br /></td></tr>
<tr class="separator:a1d2dde39243a8dab580115c16a1e15b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27ac0f031564032199e2b8702e54a9b"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_map.html#ac27ac0f031564032199e2b8702e54a9b">insert_vertex</a> (const VertKey &amp;key)</td></tr>
<tr class="memdesc:ac27ac0f031564032199e2b8702e54a9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a vertex with the given key into the graph.  <br /></td></tr>
<tr class="separator:ac27ac0f031564032199e2b8702e54a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8790d76a9bb598b8fa190d422f4cd01d"><td class="memTemplParams" colspan="2">template&lt;Forwardable&lt; VertVal &gt; T&gt; <br />
requires (HasVertKey() and HasVertexValue())</td></tr>
<tr class="memitem:a8790d76a9bb598b8fa190d422f4cd01d"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_map.html#a8790d76a9bb598b8fa190d422f4cd01d">insert_vertex</a> (const VertKey &amp;key, T &amp;&amp;value)</td></tr>
<tr class="memdesc:a8790d76a9bb598b8fa190d422f4cd01d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a vertex with the given key and value into the graph.  <br /></td></tr>
<tr class="separator:a8790d76a9bb598b8fa190d422f4cd01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0c4e18c3ae0ddb040eb3f32bbd447e"><td class="memTemplParams" colspan="2">template&lt;Forwardable&lt; VertVal &gt; T&gt; <br />
requires (not HasVertKey() and HasVertexValue())</td></tr>
<tr class="memitem:a0b0c4e18c3ae0ddb040eb3f32bbd447e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_map.html#a0b0c4e18c3ae0ddb040eb3f32bbd447e">insert_vertex</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:a0b0c4e18c3ae0ddb040eb3f32bbd447e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a vertex with the given value into the graph.  <br /></td></tr>
<tr class="separator:a0b0c4e18c3ae0ddb040eb3f32bbd447e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb988b27bf2c50963fcdc177e4dec20c"><td class="memItemLeft" align="right" valign="top"><a id="aeb988b27bf2c50963fcdc177e4dec20c" name="aeb988b27bf2c50963fcdc177e4dec20c"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert_vertex</b> ()</td></tr>
<tr class="separator:aeb988b27bf2c50963fcdc177e4dec20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada345428a50d8e94fbf6a1df879d7548"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; <br />
requires (HasVertKey() and HasVertexValue())</td></tr>
<tr class="memitem:ada345428a50d8e94fbf6a1df879d7548"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_map.html#ada345428a50d8e94fbf6a1df879d7548">emplace_vertex</a> (const VertKey &amp;key, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ada345428a50d8e94fbf6a1df879d7548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplaces a vertex with the given key and value construction arguments into the graph.  <br /></td></tr>
<tr class="separator:ada345428a50d8e94fbf6a1df879d7548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e99f5145459cf57a0031909bdc2cda9"><td class="memTemplParams" colspan="2"><a id="a4e99f5145459cf57a0031909bdc2cda9" name="a4e99f5145459cf57a0031909bdc2cda9"></a>
template&lt;typename... Args&gt; <br />
requires (not HasVertKey() and HasVertexValue())</td></tr>
<tr class="memitem:a4e99f5145459cf57a0031909bdc2cda9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_vertex</b> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a4e99f5145459cf57a0031909bdc2cda9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplaces a vertex with the given value construction arguments into the graph, returning an iterator to the new vertex. <br /></td></tr>
<tr class="separator:a4e99f5145459cf57a0031909bdc2cda9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf48fefe379fcc852865dfdc6bf8a14"><td class="memTemplParams" colspan="2">template&lt;Forwardable&lt; VertVal &gt; T&gt; <br />
requires (HasVertKey() and HasVertexValue())</td></tr>
<tr class="memitem:aedf48fefe379fcc852865dfdc6bf8a14"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_map.html#aedf48fefe379fcc852865dfdc6bf8a14">insert_or_assign_vertex</a> (const VertKey &amp;key, T &amp;&amp;value)</td></tr>
<tr class="memdesc:aedf48fefe379fcc852865dfdc6bf8a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a vertex with the given key and value into the graph.  <br /></td></tr>
<tr class="separator:aedf48fefe379fcc852865dfdc6bf8a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d264055f64c1758bebfc7fae309619"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; <br />
requires (HasEdgeKey())</td></tr>
<tr class="memitem:ab1d264055f64c1758bebfc7fae309619"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_map.html#ab1d264055f64c1758bebfc7fae309619">emplace_directed_edge</a> (const EdgeKey &amp;new_key, <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> src, <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> dst, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ab1d264055f64c1758bebfc7fae309619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an undirected edge with the given key and value construction arguments into the graph.  <br /></td></tr>
<tr class="separator:ab1d264055f64c1758bebfc7fae309619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3696d4086c67b10e7c0704fd1e29d4"><td class="memTemplParams" colspan="2"><a id="add3696d4086c67b10e7c0704fd1e29d4" name="add3696d4086c67b10e7c0704fd1e29d4"></a>
template&lt;typename... Args&gt; <br />
requires (HasEdgeKey() and HasVertKey())</td></tr>
<tr class="memitem:add3696d4086c67b10e7c0704fd1e29d4"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_directed_edge</b> (const EdgeKey &amp;new_key, const VertKey &amp;src_key, const VertKey &amp;dst_key, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:add3696d4086c67b10e7c0704fd1e29d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new edge from an <code>EdgeKey</code> and two <code>VertKey</code>s. <br /></td></tr>
<tr class="separator:add3696d4086c67b10e7c0704fd1e29d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5346c0812bce453a497abd101a1210f0"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; <br />
requires (not HasEdgeKey())</td></tr>
<tr class="memitem:a5346c0812bce453a497abd101a1210f0"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_map.html#a5346c0812bce453a497abd101a1210f0">emplace_directed_edge</a> (<a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> src, <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> dst, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a5346c0812bce453a497abd101a1210f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new un-keyed edge from two vertex iterators.  <br /></td></tr>
<tr class="separator:a5346c0812bce453a497abd101a1210f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2236384431118d21611af41da3774e0e"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; <br />
requires (not HasEdgeKey() and HasVertKey())</td></tr>
<tr class="memitem:a2236384431118d21611af41da3774e0e"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_map.html#a2236384431118d21611af41da3774e0e">emplace_directed_edge</a> (const VertKey &amp;src_key, const VertKey &amp;dst_key, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a2236384431118d21611af41da3774e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new un-keyed edge from two vertex keys.  <br /></td></tr>
<tr class="separator:a2236384431118d21611af41da3774e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2a23b0a71f6aae2b55bc46b5a8dd1b"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; <br />
requires (HasEdgeKey())</td></tr>
<tr class="memitem:a3a2a23b0a71f6aae2b55bc46b5a8dd1b"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_map.html#a3a2a23b0a71f6aae2b55bc46b5a8dd1b">emplace_directed_edge_before</a> (const EdgeKey &amp;new_key, std::variant&lt; <a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">edge_iterator</a>, <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> &gt; src, std::variant&lt; <a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">edge_iterator</a>, <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> &gt; dst, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a3a2a23b0a71f6aae2b55bc46b5a8dd1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new edge with the given key into the graph before each given edge.  <br /></td></tr>
<tr class="separator:a3a2a23b0a71f6aae2b55bc46b5a8dd1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29a7a394d70eddeb2b8ab4696530091"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; <br />
requires (not HasVertKey())</td></tr>
<tr class="memitem:ae29a7a394d70eddeb2b8ab4696530091"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_map.html#ae29a7a394d70eddeb2b8ab4696530091">emplace_directed_edge_before</a> (std::variant&lt; <a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">edge_iterator</a>, <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> &gt; src, std::variant&lt; <a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">edge_iterator</a>, <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> &gt; dst, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ae29a7a394d70eddeb2b8ab4696530091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an un-keyed edge at a specific place in the edge sequence.  <br /></td></tr>
<tr class="separator:ae29a7a394d70eddeb2b8ab4696530091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517e2191b023dbaa24955755cbf11dca"><td class="memItemLeft" align="right" valign="top"><a id="a517e2191b023dbaa24955755cbf11dca" name="a517e2191b023dbaa24955755cbf11dca"></a>
std::pair&lt; <a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>, <a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>insert_undirected_edge</b> (<a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> src, <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> dst)</td></tr>
<tr class="separator:a517e2191b023dbaa24955755cbf11dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ab7ad32fdcfa5e920b76d303775d1e"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; <br />
requires (HasEdgeKey())</td></tr>
<tr class="memitem:a05ab7ad32fdcfa5e920b76d303775d1e"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">edge_iterator</a>, EdgeChange &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_map.html#a05ab7ad32fdcfa5e920b76d303775d1e">redirect_edge</a> (const EdgeKey &amp;key, <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> src, <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> dst, Args... args)</td></tr>
<tr class="memdesc:a05ab7ad32fdcfa5e920b76d303775d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate the edge key with a directed edge between the given vertices.  <br /></td></tr>
<tr class="separator:a05ab7ad32fdcfa5e920b76d303775d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d02212774529a2d8c66dd058119abf"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; <br />
requires (HasEdgeKey() and HasEdgeValue())</td></tr>
<tr class="memitem:a12d02212774529a2d8c66dd058119abf"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_map.html#a12d02212774529a2d8c66dd058119abf">try_redirect_edge</a> (const EdgeKey &amp;key, <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> src, <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> dst, Args... args)</td></tr>
<tr class="memdesc:a12d02212774529a2d8c66dd058119abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the endpoints of the edge with the given key, preserving the edge's value if one exists.  <br /></td></tr>
<tr class="separator:a12d02212774529a2d8c66dd058119abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ffa3bdc586e66bd90b92fdeb3176d3"><td class="memItemLeft" align="right" valign="top"><a id="a04ffa3bdc586e66bd90b92fdeb3176d3" name="a04ffa3bdc586e66bd90b92fdeb3176d3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>contains</b> (VertexId vid) const</td></tr>
<tr class="memdesc:a04ffa3bdc586e66bd90b92fdeb3176d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the graph contains a vertex with the given id. <br /></td></tr>
<tr class="separator:a04ffa3bdc586e66bd90b92fdeb3176d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b12879230ce2ebb30363c4de8a29808"><td class="memItemLeft" align="right" valign="top"><a id="a1b12879230ce2ebb30363c4de8a29808" name="a1b12879230ce2ebb30363c4de8a29808"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>contains</b> (EdgeId eid) const</td></tr>
<tr class="memdesc:a1b12879230ce2ebb30363c4de8a29808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the graph contains an edge with the given id. <br /></td></tr>
<tr class="separator:a1b12879230ce2ebb30363c4de8a29808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bdd6d25f2ef79bc80d4f18a97cb8a00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_map.html#a7bdd6d25f2ef79bc80d4f18a97cb8a00">find_vertex</a> (VertexId v)</td></tr>
<tr class="memdesc:a7bdd6d25f2ef79bc80d4f18a97cb8a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the vertex with the given id and return a mutable iterator to it.  <br /></td></tr>
<tr class="separator:a7bdd6d25f2ef79bc80d4f18a97cb8a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2083cc486407e88f43afc54010dc1cf1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">const_vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_map.html#a2083cc486407e88f43afc54010dc1cf1">find_vertex</a> (VertexId v) const</td></tr>
<tr class="memdesc:a2083cc486407e88f43afc54010dc1cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the vertex with the given id and return a const iterator to it.  <br /></td></tr>
<tr class="separator:a2083cc486407e88f43afc54010dc1cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51033fff8c4dcab66007bec179c2e50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_map.html#aa51033fff8c4dcab66007bec179c2e50">find_edge</a> (EdgeId e, EdgeDir dir=EdgeDir::Outgoing)</td></tr>
<tr class="memdesc:aa51033fff8c4dcab66007bec179c2e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator pointing to the vertex with the given id.  <br /></td></tr>
<tr class="separator:aa51033fff8c4dcab66007bec179c2e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d6728dca23fc72667089d763fe953b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">const_incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_map.html#a72d6728dca23fc72667089d763fe953b">find_edge</a> (EdgeId e, EdgeDir dir=EdgeDir::Outgoing) const</td></tr>
<tr class="memdesc:a72d6728dca23fc72667089d763fe953b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const iterator pointing to the vertex with the given id.  <br /></td></tr>
<tr class="separator:a72d6728dca23fc72667089d763fe953b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae805ed41f16480845c0b8c080d89fb7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_map.html#ae805ed41f16480845c0b8c080d89fb7b">find_edge</a> (<a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">const_vertex_iterator</a> v0, <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">const_vertex_iterator</a> v1)</td></tr>
<tr class="memdesc:ae805ed41f16480845c0b8c080d89fb7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the edge connecting the two given vertices.  <br /></td></tr>
<tr class="separator:ae805ed41f16480845c0b8c080d89fb7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa170b72190d6a1bee2189fc14015a5bc"><td class="memItemLeft" align="right" valign="top"><a id="aa170b72190d6a1bee2189fc14015a5bc" name="aa170b72190d6a1bee2189fc14015a5bc"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>find_edge</b> (<a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> v0, <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> v1)</td></tr>
<tr class="separator:aa170b72190d6a1bee2189fc14015a5bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e8e34c1ddde1c701fb1f5320775c7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">const_incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_map.html#af7e8e34c1ddde1c701fb1f5320775c7e">find_edge</a> (<a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">const_vertex_iterator</a> v0, <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">const_vertex_iterator</a> v1) const</td></tr>
<tr class="memdesc:af7e8e34c1ddde1c701fb1f5320775c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the edge connecting the two given vertices.  <br /></td></tr>
<tr class="separator:af7e8e34c1ddde1c701fb1f5320775c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672dc9fa3b145759db6bfa8bb1b891d6"><td class="memItemLeft" align="right" valign="top"><a id="a672dc9fa3b145759db6bfa8bb1b891d6" name="a672dc9fa3b145759db6bfa8bb1b891d6"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>find_edge</b> (VertexId v0, VertexId v1)</td></tr>
<tr class="memdesc:a672dc9fa3b145759db6bfa8bb1b891d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>find_edge(find_vertex(v0), find_vertex(v1))</code>. <br /></td></tr>
<tr class="separator:a672dc9fa3b145759db6bfa8bb1b891d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c55b2e7fe82a49fcde3ca05a121c707"><td class="memItemLeft" align="right" valign="top"><a id="a9c55b2e7fe82a49fcde3ca05a121c707" name="a9c55b2e7fe82a49fcde3ca05a121c707"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">const_incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>find_edge</b> (VertexId v0, VertexId v1) const</td></tr>
<tr class="memdesc:a9c55b2e7fe82a49fcde3ca05a121c707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>find_edge(find_vertex(v0), find_vertex(v1))</code>. <br /></td></tr>
<tr class="separator:a9c55b2e7fe82a49fcde3ca05a121c707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883da5c3b15937b7e53c49ff34e8434b"><td class="memItemLeft" align="right" valign="top"><a id="a883da5c3b15937b7e53c49ff34e8434b" name="a883da5c3b15937b7e53c49ff34e8434b"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>find_edge</b> (<a class="el" href="structgraph_1_1_edge.html">Edge</a> e)</td></tr>
<tr class="memdesc:a883da5c3b15937b7e53c49ff34e8434b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>find_edge(e.v0, e.v1)</code>. <br /></td></tr>
<tr class="separator:a883da5c3b15937b7e53c49ff34e8434b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9130f92722890203ce3e3f20c1d3950"><td class="memItemLeft" align="right" valign="top"><a id="aa9130f92722890203ce3e3f20c1d3950" name="aa9130f92722890203ce3e3f20c1d3950"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">const_incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>find_edge</b> (<a class="el" href="structgraph_1_1_edge.html">Edge</a> e) const</td></tr>
<tr class="memdesc:aa9130f92722890203ce3e3f20c1d3950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>find_edge(e.v0, e.v1)</code>. <br /></td></tr>
<tr class="separator:aa9130f92722890203ce3e3f20c1d3950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a291b3fcfc3dce1e8a0bf00489c66c4be"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structgraph_1_1_digraph_1_1_vertex_ref.html">vertex_ref</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_map.html#a291b3fcfc3dce1e8a0bf00489c66c4be">vertex</a> (VertexId v)</td></tr>
<tr class="memdesc:a291b3fcfc3dce1e8a0bf00489c66c4be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the vertex with the given id, if it exists.  <br /></td></tr>
<tr class="separator:a291b3fcfc3dce1e8a0bf00489c66c4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f560df464a4c711f6182e3f344a064"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structgraph_1_1_digraph_1_1_vertex_ref.html">const_vertex_ref</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_map.html#af6f560df464a4c711f6182e3f344a064">vertex</a> (VertexId v) const</td></tr>
<tr class="memdesc:af6f560df464a4c711f6182e3f344a064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the vertex with the given id, if it exists.  <br /></td></tr>
<tr class="separator:af6f560df464a4c711f6182e3f344a064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structgraph_1_1_digraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structgraph_1_1_digraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="structgraph_1_1_digraph.html">graph::Digraph&lt; V, E, Map &gt;</a></td></tr>
<tr class="memitem:afc76c059d8c510e7ddd115d386c45e72 inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_ref.html">const_vertex_ref</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#afc76c059d8c510e7ddd115d386c45e72">operator[]</a> (VertexId v) const</td></tr>
<tr class="memdesc:afc76c059d8c510e7ddd115d386c45e72 inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a const reference to the vertex with the given id.  <br /></td></tr>
<tr class="separator:afc76c059d8c510e7ddd115d386c45e72 inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8204ccba579f1f814836f1479b126b1 inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_ref.html">vertex_ref</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#af8204ccba579f1f814836f1479b126b1">operator[]</a> (VertexId v)</td></tr>
<tr class="memdesc:af8204ccba579f1f814836f1479b126b1 inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a reference to the vertex with the given id.  <br /></td></tr>
<tr class="separator:af8204ccba579f1f814836f1479b126b1 inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573685de7e8d6324f90e3f02ecf61bea inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_edge_ref.html">const_edge_ref</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#a573685de7e8d6324f90e3f02ecf61bea">operator[]</a> (EdgeId e) const</td></tr>
<tr class="memdesc:a573685de7e8d6324f90e3f02ecf61bea inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a const reference to the edge with the given id.  <br /></td></tr>
<tr class="separator:a573685de7e8d6324f90e3f02ecf61bea inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8a238f097f3c7665a12fff755dd95f3 inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_edge_ref.html">edge_ref</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#ac8a238f097f3c7665a12fff755dd95f3">operator[]</a> (EdgeId e)</td></tr>
<tr class="memdesc:ac8a238f097f3c7665a12fff755dd95f3 inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a reference to the edge with the given id.  <br /></td></tr>
<tr class="separator:ac8a238f097f3c7665a12fff755dd95f3 inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ffa3bdc586e66bd90b92fdeb3176d3 inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="a04ffa3bdc586e66bd90b92fdeb3176d3" name="a04ffa3bdc586e66bd90b92fdeb3176d3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>contains</b> (VertexId vid) const</td></tr>
<tr class="memdesc:a04ffa3bdc586e66bd90b92fdeb3176d3 inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the graph contains a vertex with the given id. <br /></td></tr>
<tr class="separator:a04ffa3bdc586e66bd90b92fdeb3176d3 inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b12879230ce2ebb30363c4de8a29808 inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="a1b12879230ce2ebb30363c4de8a29808" name="a1b12879230ce2ebb30363c4de8a29808"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>contains</b> (EdgeId eid) const</td></tr>
<tr class="memdesc:a1b12879230ce2ebb30363c4de8a29808 inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the graph contains an edge with the given id. <br /></td></tr>
<tr class="separator:a1b12879230ce2ebb30363c4de8a29808 inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af052c89504e5ef4f121410647d7ac865 inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="af052c89504e5ef4f121410647d7ac865" name="af052c89504e5ef4f121410647d7ac865"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert_vertex</b> ()</td></tr>
<tr class="memdesc:af052c89504e5ef4f121410647d7ac865 inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new vertex into the graph, and return an iterator to it. <br /></td></tr>
<tr class="separator:af052c89504e5ef4f121410647d7ac865 inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c766be3a5d8e65ce72bd811482d37f inherit pub_methods_structgraph_1_1_digraph"><td class="memTemplParams" colspan="2">template&lt;Forwardable&lt; V &gt; T&gt; <br />
requires (HasVertexValue())</td></tr>
<tr class="memitem:a72c766be3a5d8e65ce72bd811482d37f inherit pub_methods_structgraph_1_1_digraph"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#a72c766be3a5d8e65ce72bd811482d37f">insert_vertex</a> (T &amp;&amp;v)</td></tr>
<tr class="separator:a72c766be3a5d8e65ce72bd811482d37f inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a308f3ed01474186bf8f37f822a3f57d3 inherit pub_methods_structgraph_1_1_digraph"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; <br />
requires (HasVertexValue())</td></tr>
<tr class="memitem:a308f3ed01474186bf8f37f822a3f57d3 inherit pub_methods_structgraph_1_1_digraph"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#a308f3ed01474186bf8f37f822a3f57d3">emplace_vertex</a> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:a308f3ed01474186bf8f37f822a3f57d3 inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e04e2f0d5a38577b3ca3ca5640322a inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#a11e04e2f0d5a38577b3ca3ca5640322a">erase</a> (<a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> v)</td></tr>
<tr class="memdesc:a11e04e2f0d5a38577b3ca3ca5640322a inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the given vertex, and return an iterator to the following vertex.  <br /></td></tr>
<tr class="separator:a11e04e2f0d5a38577b3ca3ca5640322a inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c6a7d8c1e8358a6dac4c04103332ff inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#a54c6a7d8c1e8358a6dac4c04103332ff">erase</a> (VertexId vid)</td></tr>
<tr class="memdesc:a54c6a7d8c1e8358a6dac4c04103332ff inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the vertex with the given ID, and return an iterator to the following vertex.  <br /></td></tr>
<tr class="separator:a54c6a7d8c1e8358a6dac4c04103332ff inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d66bc2cc6099934368b859cd12ea0a inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="a62d66bc2cc6099934368b859cd12ea0a" name="a62d66bc2cc6099934368b859cd12ea0a"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_vertex_range.html">VertexRange</a>&lt; Constness::Mutable &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>vertices</b> ()</td></tr>
<tr class="memdesc:a62d66bc2cc6099934368b859cd12ea0a inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">A range of all the vertices in the graph. <br /></td></tr>
<tr class="separator:a62d66bc2cc6099934368b859cd12ea0a inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cfc2534b42a9e77169361c22c8f1f42 inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="a1cfc2534b42a9e77169361c22c8f1f42" name="a1cfc2534b42a9e77169361c22c8f1f42"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_vertex_range.html">VertexRange</a>&lt; Constness::Const &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>vertices</b> () const</td></tr>
<tr class="memdesc:a1cfc2534b42a9e77169361c22c8f1f42 inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">An immutable range of all the vertices in the graph. <br /></td></tr>
<tr class="separator:a1cfc2534b42a9e77169361c22c8f1f42 inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13290ba8d07cc281487e09328c6dc803 inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#a13290ba8d07cc281487e09328c6dc803">begin_vertices</a> ()</td></tr>
<tr class="memdesc:a13290ba8d07cc281487e09328c6dc803 inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator pointing to the first vertex in the graph.  <br /></td></tr>
<tr class="separator:a13290ba8d07cc281487e09328c6dc803 inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29fc6bcdf6b17be31c43ca6fac346754 inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="a29fc6bcdf6b17be31c43ca6fac346754" name="a29fc6bcdf6b17be31c43ca6fac346754"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end_vertices</b> ()</td></tr>
<tr class="memdesc:a29fc6bcdf6b17be31c43ca6fac346754 inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sentinel iterator pointing beyond the end of the range of vertices. <br /></td></tr>
<tr class="separator:a29fc6bcdf6b17be31c43ca6fac346754 inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8b671c032c844c02fd2fd2f8056ccb inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">const_vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#a9c8b671c032c844c02fd2fd2f8056ccb">begin_vertices</a> () const</td></tr>
<tr class="memdesc:a9c8b671c032c844c02fd2fd2f8056ccb inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const iterator pointing to the first vertex in the graph.  <br /></td></tr>
<tr class="separator:a9c8b671c032c844c02fd2fd2f8056ccb inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec9d19219f488e7c15f8b5b06c1b6dd inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="afec9d19219f488e7c15f8b5b06c1b6dd" name="afec9d19219f488e7c15f8b5b06c1b6dd"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">const_vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end_vertices</b> () const</td></tr>
<tr class="memdesc:afec9d19219f488e7c15f8b5b06c1b6dd inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const sentinel iterator pointing beyond the end of the range of vertices. <br /></td></tr>
<tr class="separator:afec9d19219f488e7c15f8b5b06c1b6dd inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7794317dca2c5b157ecb20b4194638f6 inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="a7794317dca2c5b157ecb20b4194638f6" name="a7794317dca2c5b157ecb20b4194638f6"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">const_vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin_vertices</b> () const</td></tr>
<tr class="separator:a7794317dca2c5b157ecb20b4194638f6 inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab981dca5d3858d6fd8bd0ae136734b23 inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="ab981dca5d3858d6fd8bd0ae136734b23" name="ab981dca5d3858d6fd8bd0ae136734b23"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">const_vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cend_vertices</b> () const</td></tr>
<tr class="separator:ab981dca5d3858d6fd8bd0ae136734b23 inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9121bd6cd3bdf2657400943acc4b4314 inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="a9121bd6cd3bdf2657400943acc4b4314" name="a9121bd6cd3bdf2657400943acc4b4314"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>vertices_size</b> () const</td></tr>
<tr class="memdesc:a9121bd6cd3bdf2657400943acc4b4314 inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of vertices in the graph. <br /></td></tr>
<tr class="separator:a9121bd6cd3bdf2657400943acc4b4314 inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208d46dcca7fa0f4fadc42720efa10f6 inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="a208d46dcca7fa0f4fadc42720efa10f6" name="a208d46dcca7fa0f4fadc42720efa10f6"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_edge_range.html">EdgeRange</a>&lt; Constness::Mutable &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>edges</b> ()</td></tr>
<tr class="memdesc:a208d46dcca7fa0f4fadc42720efa10f6 inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">A range of all the edges in the graph. <br /></td></tr>
<tr class="separator:a208d46dcca7fa0f4fadc42720efa10f6 inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7211a982588e79a0025bcd2996997d59 inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="a7211a982588e79a0025bcd2996997d59" name="a7211a982588e79a0025bcd2996997d59"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_edge_range.html">EdgeRange</a>&lt; Constness::Const &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>edges</b> () const</td></tr>
<tr class="memdesc:a7211a982588e79a0025bcd2996997d59 inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">An immutable range of all the edges in the graph. <br /></td></tr>
<tr class="separator:a7211a982588e79a0025bcd2996997d59 inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178df2c954b82cb9c94db2fc6b6cad00 inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#a178df2c954b82cb9c94db2fc6b6cad00">begin_edges</a> ()</td></tr>
<tr class="memdesc:a178df2c954b82cb9c94db2fc6b6cad00 inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator pointing to the first edge in the graph.  <br /></td></tr>
<tr class="separator:a178df2c954b82cb9c94db2fc6b6cad00 inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af246167edd4ec5c4bac29f81969f4b2b inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="af246167edd4ec5c4bac29f81969f4b2b" name="af246167edd4ec5c4bac29f81969f4b2b"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end_edges</b> ()</td></tr>
<tr class="memdesc:af246167edd4ec5c4bac29f81969f4b2b inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sentinel iterator pointing beyond the end of the range of edges. <br /></td></tr>
<tr class="separator:af246167edd4ec5c4bac29f81969f4b2b inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42854027cafca6577d5c1230857a5a0e inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">const_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#a42854027cafca6577d5c1230857a5a0e">begin_edges</a> () const</td></tr>
<tr class="memdesc:a42854027cafca6577d5c1230857a5a0e inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const iterator pointing to the first edge in the graph.  <br /></td></tr>
<tr class="separator:a42854027cafca6577d5c1230857a5a0e inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae3eb784540e7abc4d391ef670a17dea inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="aae3eb784540e7abc4d391ef670a17dea" name="aae3eb784540e7abc4d391ef670a17dea"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">const_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end_edges</b> () const</td></tr>
<tr class="memdesc:aae3eb784540e7abc4d391ef670a17dea inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const sentinel iterator pointing beyond the end of the range of edges. <br /></td></tr>
<tr class="separator:aae3eb784540e7abc4d391ef670a17dea inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62036a949a11e641a53bbb2b1c8a0b51 inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="a62036a949a11e641a53bbb2b1c8a0b51" name="a62036a949a11e641a53bbb2b1c8a0b51"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>edges_size</b> () const</td></tr>
<tr class="memdesc:a62036a949a11e641a53bbb2b1c8a0b51 inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of edges in the graph. <br /></td></tr>
<tr class="separator:a62036a949a11e641a53bbb2b1c8a0b51 inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bdd6d25f2ef79bc80d4f18a97cb8a00 inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#a7bdd6d25f2ef79bc80d4f18a97cb8a00">find_vertex</a> (VertexId v)</td></tr>
<tr class="memdesc:a7bdd6d25f2ef79bc80d4f18a97cb8a00 inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the vertex with the given id and return a mutable iterator to it.  <br /></td></tr>
<tr class="separator:a7bdd6d25f2ef79bc80d4f18a97cb8a00 inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2083cc486407e88f43afc54010dc1cf1 inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">const_vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#a2083cc486407e88f43afc54010dc1cf1">find_vertex</a> (VertexId v) const</td></tr>
<tr class="memdesc:a2083cc486407e88f43afc54010dc1cf1 inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the vertex with the given id and return a const iterator to it.  <br /></td></tr>
<tr class="separator:a2083cc486407e88f43afc54010dc1cf1 inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a291b3fcfc3dce1e8a0bf00489c66c4be inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structgraph_1_1_digraph_1_1_vertex_ref.html">vertex_ref</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#a291b3fcfc3dce1e8a0bf00489c66c4be">vertex</a> (VertexId v)</td></tr>
<tr class="memdesc:a291b3fcfc3dce1e8a0bf00489c66c4be inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the vertex with the given id, if it exists.  <br /></td></tr>
<tr class="separator:a291b3fcfc3dce1e8a0bf00489c66c4be inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f560df464a4c711f6182e3f344a064 inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structgraph_1_1_digraph_1_1_vertex_ref.html">const_vertex_ref</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#af6f560df464a4c711f6182e3f344a064">vertex</a> (VertexId v) const</td></tr>
<tr class="memdesc:af6f560df464a4c711f6182e3f344a064 inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the vertex with the given id, if it exists.  <br /></td></tr>
<tr class="separator:af6f560df464a4c711f6182e3f344a064 inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1412d78dea33431034af24655489b275 inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_range.html">IncidentEdgeRange</a>&lt; Constness::Mutable &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#a1412d78dea33431034af24655489b275">incident_edges</a> (VertexId v, EdgeDir dir=EdgeDir::Outgoing)</td></tr>
<tr class="memdesc:a1412d78dea33431034af24655489b275 inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a range of edges which traverses all the edges incident to <code>v</code> in the given direction.  <br /></td></tr>
<tr class="separator:a1412d78dea33431034af24655489b275 inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319c9e8ee9680933c7d35f30f7f86ec3 inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_range.html">IncidentEdgeRange</a>&lt; Constness::Const &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#a319c9e8ee9680933c7d35f30f7f86ec3">incident_edges</a> (VertexId v, EdgeDir dir=EdgeDir::Outgoing) const</td></tr>
<tr class="memdesc:a319c9e8ee9680933c7d35f30f7f86ec3 inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a range of immuatble edges which traverses all the edges incident to <code>v</code> in the given direction.  <br /></td></tr>
<tr class="separator:a319c9e8ee9680933c7d35f30f7f86ec3 inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53f9abd56a38ea980454416de1d87ab inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="ad53f9abd56a38ea980454416de1d87ab" name="ad53f9abd56a38ea980454416de1d87ab"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>incident_edges</b> (<a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">const_vertex_iterator</a> v, EdgeDir dir=EdgeDir::Outgoing)</td></tr>
<tr class="separator:ad53f9abd56a38ea980454416de1d87ab inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00561c9583233219ab3ee9684830326f inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="a00561c9583233219ab3ee9684830326f" name="a00561c9583233219ab3ee9684830326f"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>incident_edges</b> (<a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">const_vertex_iterator</a> v, EdgeDir dir=EdgeDir::Outgoing) const</td></tr>
<tr class="separator:a00561c9583233219ab3ee9684830326f inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b1e4290098d7bf450380f5c1bcc23d inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#a05b1e4290098d7bf450380f5c1bcc23d">begin_incident_edges</a> (<a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">const_vertex_iterator</a> v, EdgeDir dir)</td></tr>
<tr class="memdesc:a05b1e4290098d7bf450380f5c1bcc23d inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator pointing to the first edge incident to <code>v</code> in the given direction.  <br /></td></tr>
<tr class="separator:a05b1e4290098d7bf450380f5c1bcc23d inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71da45f3729ba95203619a75bad40a7d inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">const_incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#a71da45f3729ba95203619a75bad40a7d">begin_incident_edges</a> (<a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">const_vertex_iterator</a> v, EdgeDir dir) const</td></tr>
<tr class="memdesc:a71da45f3729ba95203619a75bad40a7d inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const iterator pointing to the first edge incident to <code>v</code> in the given direction.  <br /></td></tr>
<tr class="separator:a71da45f3729ba95203619a75bad40a7d inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abffa05252d8cad2593b5001e622e6d5e inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="abffa05252d8cad2593b5001e622e6d5e" name="abffa05252d8cad2593b5001e622e6d5e"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin_incident_edges</b> (VertexId v, EdgeDir dir)</td></tr>
<tr class="memdesc:abffa05252d8cad2593b5001e622e6d5e inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>begin_incident_edges(find_vertex(v), dir)</code>. <br /></td></tr>
<tr class="separator:abffa05252d8cad2593b5001e622e6d5e inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688ddbb552213a9dca3b475512c754b6 inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="a688ddbb552213a9dca3b475512c754b6" name="a688ddbb552213a9dca3b475512c754b6"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">const_incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin_incident_edges</b> (VertexId v, EdgeDir dir) const</td></tr>
<tr class="memdesc:a688ddbb552213a9dca3b475512c754b6 inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>begin_incident_edges(find_vertex(v), dir)</code>. <br /></td></tr>
<tr class="separator:a688ddbb552213a9dca3b475512c754b6 inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace55502426f5b845686352c6e94c7d24 inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#ace55502426f5b845686352c6e94c7d24">end_incident_edges</a> (VertexId v, EdgeDir dir)</td></tr>
<tr class="memdesc:ace55502426f5b845686352c6e94c7d24 inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sentinel iterator indicating the end of the incident edge range.  <br /></td></tr>
<tr class="separator:ace55502426f5b845686352c6e94c7d24 inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e0e7e4192390b364aa655c45d21e05 inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="a68e0e7e4192390b364aa655c45d21e05" name="a68e0e7e4192390b364aa655c45d21e05"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">const_incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end_incident_edges</b> (VertexId v, EdgeDir dir) const</td></tr>
<tr class="separator:a68e0e7e4192390b364aa655c45d21e05 inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b83ce9d1bc446da311feecc621e266 inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="a89b83ce9d1bc446da311feecc621e266" name="a89b83ce9d1bc446da311feecc621e266"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">const_incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin_incident_edges</b> (VertexId v, EdgeDir dir) const</td></tr>
<tr class="separator:a89b83ce9d1bc446da311feecc621e266 inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4276b1d50856e4a61c73daa056807f7 inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="ad4276b1d50856e4a61c73daa056807f7" name="ad4276b1d50856e4a61c73daa056807f7"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">const_incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cend_incident_edges</b> () const</td></tr>
<tr class="separator:ad4276b1d50856e4a61c73daa056807f7 inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e0b8fb0592a524b3ceebd8953262c2 inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#ae0e0b8fb0592a524b3ceebd8953262c2">incident_edges_size</a> (<a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">const_vertex_iterator</a> v, EdgeDir dir) const</td></tr>
<tr class="memdesc:ae0e0b8fb0592a524b3ceebd8953262c2 inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of edges incident to the given vertex in the given direction.  <br /></td></tr>
<tr class="separator:ae0e0b8fb0592a524b3ceebd8953262c2 inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51033fff8c4dcab66007bec179c2e50 inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#aa51033fff8c4dcab66007bec179c2e50">find_edge</a> (EdgeId e, EdgeDir dir=EdgeDir::Outgoing)</td></tr>
<tr class="memdesc:aa51033fff8c4dcab66007bec179c2e50 inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator pointing to the vertex with the given id.  <br /></td></tr>
<tr class="separator:aa51033fff8c4dcab66007bec179c2e50 inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d6728dca23fc72667089d763fe953b inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">const_incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#a72d6728dca23fc72667089d763fe953b">find_edge</a> (EdgeId e, EdgeDir dir=EdgeDir::Outgoing) const</td></tr>
<tr class="memdesc:a72d6728dca23fc72667089d763fe953b inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const iterator pointing to the vertex with the given id.  <br /></td></tr>
<tr class="separator:a72d6728dca23fc72667089d763fe953b inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae805ed41f16480845c0b8c080d89fb7b inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#ae805ed41f16480845c0b8c080d89fb7b">find_edge</a> (<a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">const_vertex_iterator</a> v0, <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">const_vertex_iterator</a> v1)</td></tr>
<tr class="memdesc:ae805ed41f16480845c0b8c080d89fb7b inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the edge connecting the two given vertices.  <br /></td></tr>
<tr class="separator:ae805ed41f16480845c0b8c080d89fb7b inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa170b72190d6a1bee2189fc14015a5bc inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="aa170b72190d6a1bee2189fc14015a5bc" name="aa170b72190d6a1bee2189fc14015a5bc"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>find_edge</b> (<a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> v0, <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> v1)</td></tr>
<tr class="separator:aa170b72190d6a1bee2189fc14015a5bc inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e8e34c1ddde1c701fb1f5320775c7e inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">const_incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#af7e8e34c1ddde1c701fb1f5320775c7e">find_edge</a> (<a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">const_vertex_iterator</a> v0, <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">const_vertex_iterator</a> v1) const</td></tr>
<tr class="memdesc:af7e8e34c1ddde1c701fb1f5320775c7e inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the edge connecting the two given vertices.  <br /></td></tr>
<tr class="separator:af7e8e34c1ddde1c701fb1f5320775c7e inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672dc9fa3b145759db6bfa8bb1b891d6 inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="a672dc9fa3b145759db6bfa8bb1b891d6" name="a672dc9fa3b145759db6bfa8bb1b891d6"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>find_edge</b> (VertexId v0, VertexId v1)</td></tr>
<tr class="memdesc:a672dc9fa3b145759db6bfa8bb1b891d6 inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>find_edge(find_vertex(v0), find_vertex(v1))</code>. <br /></td></tr>
<tr class="separator:a672dc9fa3b145759db6bfa8bb1b891d6 inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c55b2e7fe82a49fcde3ca05a121c707 inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="a9c55b2e7fe82a49fcde3ca05a121c707" name="a9c55b2e7fe82a49fcde3ca05a121c707"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">const_incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>find_edge</b> (VertexId v0, VertexId v1) const</td></tr>
<tr class="memdesc:a9c55b2e7fe82a49fcde3ca05a121c707 inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>find_edge(find_vertex(v0), find_vertex(v1))</code>. <br /></td></tr>
<tr class="separator:a9c55b2e7fe82a49fcde3ca05a121c707 inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883da5c3b15937b7e53c49ff34e8434b inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="a883da5c3b15937b7e53c49ff34e8434b" name="a883da5c3b15937b7e53c49ff34e8434b"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>find_edge</b> (<a class="el" href="structgraph_1_1_edge.html">Edge</a> e)</td></tr>
<tr class="memdesc:a883da5c3b15937b7e53c49ff34e8434b inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>find_edge(e.v0, e.v1)</code>. <br /></td></tr>
<tr class="separator:a883da5c3b15937b7e53c49ff34e8434b inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9130f92722890203ce3e3f20c1d3950 inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="aa9130f92722890203ce3e3f20c1d3950" name="aa9130f92722890203ce3e3f20c1d3950"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">const_incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>find_edge</b> (<a class="el" href="structgraph_1_1_edge.html">Edge</a> e) const</td></tr>
<tr class="memdesc:aa9130f92722890203ce3e3f20c1d3950 inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>find_edge(e.v0, e.v1)</code>. <br /></td></tr>
<tr class="separator:aa9130f92722890203ce3e3f20c1d3950 inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad383717d9f9dd6c07c6be47e6f0201e1 inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="ad383717d9f9dd6c07c6be47e6f0201e1" name="ad383717d9f9dd6c07c6be47e6f0201e1"></a>
std::optional&lt; <a class="el" href="structgraph_1_1_digraph_1_1_edge_ref.html">edge_ref</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>edge</b> (EdgeId edge)</td></tr>
<tr class="memdesc:ad383717d9f9dd6c07c6be47e6f0201e1 inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the edge with the given id. <br /></td></tr>
<tr class="separator:ad383717d9f9dd6c07c6be47e6f0201e1 inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f10850e7edd1b74a7f4be8b2dee5b0e inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="a8f10850e7edd1b74a7f4be8b2dee5b0e" name="a8f10850e7edd1b74a7f4be8b2dee5b0e"></a>
std::optional&lt; <a class="el" href="structgraph_1_1_digraph_1_1_edge_ref.html">const_edge_ref</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>edge</b> (EdgeId edge) const</td></tr>
<tr class="memdesc:a8f10850e7edd1b74a7f4be8b2dee5b0e inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the edge with the given id. <br /></td></tr>
<tr class="separator:a8f10850e7edd1b74a7f4be8b2dee5b0e inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106798dd4433d287d473a7f1b3d9ca95 inherit pub_methods_structgraph_1_1_digraph"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a106798dd4433d287d473a7f1b3d9ca95 inherit pub_methods_structgraph_1_1_digraph"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#a106798dd4433d287d473a7f1b3d9ca95">emplace_directed_edge</a> (<a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> src, <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> dst, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a106798dd4433d287d473a7f1b3d9ca95 inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new edge into the graph connecting the two given vertices, constructing a new edge value in-place with the given arguments, and return an iterator to it.  <br /></td></tr>
<tr class="separator:a106798dd4433d287d473a7f1b3d9ca95 inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3837dab6fc913bdc0b7f553c9209ec7e inherit pub_methods_structgraph_1_1_digraph"><td class="memTemplParams" colspan="2"><a id="a3837dab6fc913bdc0b7f553c9209ec7e" name="a3837dab6fc913bdc0b7f553c9209ec7e"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a3837dab6fc913bdc0b7f553c9209ec7e inherit pub_methods_structgraph_1_1_digraph"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>emplace_directed_edge</b> (VertexId src, VertexId dst, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a3837dab6fc913bdc0b7f553c9209ec7e inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>emplace_directed_edge(find_vertex(src), find_vertex(dst), ...)</code> <br /></td></tr>
<tr class="separator:a3837dab6fc913bdc0b7f553c9209ec7e inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae849a778c5008eb7807ac70c0645dd8c inherit pub_methods_structgraph_1_1_digraph"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ae849a778c5008eb7807ac70c0645dd8c inherit pub_methods_structgraph_1_1_digraph"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#ae849a778c5008eb7807ac70c0645dd8c">emplace_directed_edge_before</a> (std::variant&lt; <a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">edge_iterator</a>, <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> &gt; before_outgoing, std::variant&lt; <a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">edge_iterator</a>, <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> &gt; before_incoming, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ae849a778c5008eb7807ac70c0645dd8c inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new edge into the graph before each given edge.  <br /></td></tr>
<tr class="separator:ae849a778c5008eb7807ac70c0645dd8c inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af851493b2f6a927bab78662a8c9be090 inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>, <a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#af851493b2f6a927bab78662a8c9be090">insert_undirected_edge</a> (VertexId a, VertexId b)</td></tr>
<tr class="memdesc:af851493b2f6a927bab78662a8c9be090 inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an undirected edge between the two given vertices by inserting two directed edges in opposing directions.  <br /></td></tr>
<tr class="separator:af851493b2f6a927bab78662a8c9be090 inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6793c3de1ef4d741493585e33e3c8ede inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#a6793c3de1ef4d741493585e33e3c8ede">swap_edge_order</a> (<a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">edge_iterator</a> e0, <a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">edge_iterator</a> e1, EdgeDir dir)</td></tr>
<tr class="memdesc:a6793c3de1ef4d741493585e33e3c8ede inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">In O(1) time, exchange the position of the two edges in their incident edge sequences.  <br /></td></tr>
<tr class="separator:a6793c3de1ef4d741493585e33e3c8ede inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37c145c8284d645a07b245313ad466a inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_edge_pair.html">EdgePair</a>&lt; std::optional&lt; EdgeId &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#aa37c145c8284d645a07b245313ad466a">erase_and_next_ids</a> (<a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">edge_iterator</a> <a class="el" href="structgraph_1_1_digraph.html#ad383717d9f9dd6c07c6be47e6f0201e1">edge</a>)</td></tr>
<tr class="memdesc:aa37c145c8284d645a07b245313ad466a inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the given edge, and return the IDs of edges that followed it in the incoming and outgoing edge sequences.  <br /></td></tr>
<tr class="separator:aa37c145c8284d645a07b245313ad466a inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee7b485c858855be94b6e1a831a8aab inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="afee7b485c858855be94b6e1a831a8aab" name="afee7b485c858855be94b6e1a831a8aab"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (<a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a> <a class="el" href="structgraph_1_1_digraph.html#ad383717d9f9dd6c07c6be47e6f0201e1">edge</a>)</td></tr>
<tr class="memdesc:afee7b485c858855be94b6e1a831a8aab inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the given edge, and return an iterator to the following edge in the given direction. <br /></td></tr>
<tr class="separator:afee7b485c858855be94b6e1a831a8aab inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b069fcdc9063498357ac8d029f9983 inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="a82b069fcdc9063498357ac8d029f9983" name="a82b069fcdc9063498357ac8d029f9983"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (EdgeId eid)</td></tr>
<tr class="memdesc:a82b069fcdc9063498357ac8d029f9983 inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the edge with the given id, returning an iterator to the following edge in the graph. <br /></td></tr>
<tr class="separator:a82b069fcdc9063498357ac8d029f9983 inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3605392c9b72bcbd0bd7ad680a235953 inherit pub_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="a3605392c9b72bcbd0bd7ad680a235953" name="a3605392c9b72bcbd0bd7ad680a235953"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (<a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">edge_iterator</a> <a class="el" href="structgraph_1_1_digraph.html#ad383717d9f9dd6c07c6be47e6f0201e1">edge</a>)</td></tr>
<tr class="memdesc:a3605392c9b72bcbd0bd7ad680a235953 inherit pub_methods_structgraph_1_1_digraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the given edge, returning an iterator to the following edge in the graph. <br /></td></tr>
<tr class="separator:a3605392c9b72bcbd0bd7ad680a235953 inherit pub_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a391d78a635e6224a7d7df621585a7a3f"><td class="memItemLeft" align="right" valign="top"><a id="a391d78a635e6224a7d7df621585a7a3f" name="a391d78a635e6224a7d7df621585a7a3f"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>HasVertKey</b> ()</td></tr>
<tr class="separator:a391d78a635e6224a7d7df621585a7a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d90fe847a1f020f22909e76ad988be1"><td class="memItemLeft" align="right" valign="top"><a id="a3d90fe847a1f020f22909e76ad988be1" name="a3d90fe847a1f020f22909e76ad988be1"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>HasEdgeKey</b> ()</td></tr>
<tr class="separator:a3d90fe847a1f020f22909e76ad988be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7530bb5563e1e0c83e19732182bc083a"><td class="memItemLeft" align="right" valign="top"><a id="a7530bb5563e1e0c83e19732182bc083a" name="a7530bb5563e1e0c83e19732182bc083a"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>HasVertexValue</b> ()</td></tr>
<tr class="separator:a7530bb5563e1e0c83e19732182bc083a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6826706590749b2c490020070be7fa36"><td class="memItemLeft" align="right" valign="top"><a id="a6826706590749b2c490020070be7fa36" name="a6826706590749b2c490020070be7fa36"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>HasEdgeValue</b> ()</td></tr>
<tr class="separator:a6826706590749b2c490020070be7fa36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_structgraph_1_1_digraph"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_structgraph_1_1_digraph')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="structgraph_1_1_digraph.html">graph::Digraph&lt; V, E, Map &gt;</a></td></tr>
<tr class="memitem:a7530bb5563e1e0c83e19732182bc083a inherit pub_static_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="a7530bb5563e1e0c83e19732182bc083a" name="a7530bb5563e1e0c83e19732182bc083a"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>HasVertexValue</b> ()</td></tr>
<tr class="separator:a7530bb5563e1e0c83e19732182bc083a inherit pub_static_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6826706590749b2c490020070be7fa36 inherit pub_static_methods_structgraph_1_1_digraph"><td class="memItemLeft" align="right" valign="top"><a id="a6826706590749b2c490020070be7fa36" name="a6826706590749b2c490020070be7fa36"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>HasEdgeValue</b> ()</td></tr>
<tr class="separator:a6826706590749b2c490020070be7fa36 inherit pub_static_methods_structgraph_1_1_digraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename VertKey, typename VertVal, typename EdgeKey, typename EdgeVal, template&lt; class... &gt; class Map = std::unordered_map&gt;<br />
struct graph::DigraphMap&lt; VertKey, VertVal, EdgeKey, EdgeVal, Map &gt;</div><p>A digraph class that allows vertices and/or edges to be indexed by a custom type in O(1) time. </p>
<pre class="fragment">#include &lt;graph/digraph_map.h&gt;
</pre><p> It is permitted for one of the key types to be void, in which case the corresponding indexing methods will not be available.</p>
<p>Vertices and edges will additionally be indexable by VertexId and EdgeId, respectively.</p>
<p>As in the base class, value types for vertices and edges may each be void / omitted.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VertKey</td><td>Key type for vertices. </td></tr>
    <tr><td class="paramname">VertVal</td><td>Value type for vertices. </td></tr>
    <tr><td class="paramname">EdgeKey</td><td>Key type for edges. </td></tr>
    <tr><td class="paramname">EdgeVal</td><td>Value type for edges. </td></tr>
    <tr><td class="paramname">Map</td><td>Map type to use for storing vertices and edges. Must support the same interface as std::unordered_map. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a729b388524bdbeef3e1316fdfdea304a" name="a729b388524bdbeef3e1316fdfdea304a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a729b388524bdbeef3e1316fdfdea304a">&#9670;&#160;</a></span>edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertKey , typename VertVal , typename EdgeKey , typename EdgeVal , template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="structgraph_1_1_digraph_1_1_edge_ref.html">const_edge_ref</a> &gt; <a class="el" href="structgraph_1_1_digraph_map.html">graph::DigraphMap</a>&lt; VertKey, VertVal, EdgeKey, EdgeVal, Map &gt;::edge </td>
          <td>(</td>
          <td class="paramtype">const EdgeKey &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a const reference to the edge with the given key, or <code>std::nullopt</code> if not found. </p>

</div>
</div>
<a id="ab1d264055f64c1758bebfc7fae309619" name="ab1d264055f64c1758bebfc7fae309619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1d264055f64c1758bebfc7fae309619">&#9670;&#160;</a></span>emplace_directed_edge() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertKey , typename VertVal , typename EdgeKey , typename EdgeVal , template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; <br />
requires (HasEdgeKey())</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>, bool &gt; <a class="el" href="structgraph_1_1_digraph_map.html">graph::DigraphMap</a>&lt; VertKey, VertVal, EdgeKey, EdgeVal, Map &gt;::emplace_directed_edge </td>
          <td>(</td>
          <td class="paramtype">const EdgeKey &amp;&#160;</td>
          <td class="paramname"><em>new_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an undirected edge with the given key and value construction arguments into the graph. </p>
<p>Returns a pair of an iterator to the edge with the given key, and a boolean indicating whether the edge was inserted (<code>true</code>) or already existed (<code>false</code>).</p>
<p>In the case where the edge was inserted, the value is constructed in-place from the given arguments. Otherwise, the value is left unchanged. </p>

</div>
</div>
<a id="a2236384431118d21611af41da3774e0e" name="a2236384431118d21611af41da3774e0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2236384431118d21611af41da3774e0e">&#9670;&#160;</a></span>emplace_directed_edge() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertKey , typename VertVal , typename EdgeKey , typename EdgeVal , template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; <br />
requires (not HasEdgeKey() and HasVertKey())</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>, bool &gt; <a class="el" href="structgraph_1_1_digraph_map.html">graph::DigraphMap</a>&lt; VertKey, VertVal, EdgeKey, EdgeVal, Map &gt;::emplace_directed_edge </td>
          <td>(</td>
          <td class="paramtype">const VertKey &amp;&#160;</td>
          <td class="paramname"><em>src_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VertKey &amp;&#160;</td>
          <td class="paramname"><em>dst_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new un-keyed edge from two vertex keys. </p>
<p>Not available if <code>HasEdgeKey() == true</code>. </p>

</div>
</div>
<a id="a5346c0812bce453a497abd101a1210f0" name="a5346c0812bce453a497abd101a1210f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5346c0812bce453a497abd101a1210f0">&#9670;&#160;</a></span>emplace_directed_edge() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertKey , typename VertVal , typename EdgeKey , typename EdgeVal , template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; <br />
requires (not HasEdgeKey())</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>, bool &gt; <a class="el" href="structgraph_1_1_digraph_map.html">graph::DigraphMap</a>&lt; VertKey, VertVal, EdgeKey, EdgeVal, Map &gt;::emplace_directed_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a new un-keyed edge from two vertex iterators. </p>
<p>Not available if <code>HasEdgeKey() == true</code>. </p>

</div>
</div>
<a id="a3a2a23b0a71f6aae2b55bc46b5a8dd1b" name="a3a2a23b0a71f6aae2b55bc46b5a8dd1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a2a23b0a71f6aae2b55bc46b5a8dd1b">&#9670;&#160;</a></span>emplace_directed_edge_before() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertKey , typename VertVal , typename EdgeKey , typename EdgeVal , template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; <br />
requires (HasEdgeKey())</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>, bool &gt; <a class="el" href="structgraph_1_1_digraph_map.html">graph::DigraphMap</a>&lt; VertKey, VertVal, EdgeKey, EdgeVal, Map &gt;::emplace_directed_edge_before </td>
          <td>(</td>
          <td class="paramtype">const EdgeKey &amp;&#160;</td>
          <td class="paramname"><em>new_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::variant&lt; <a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">edge_iterator</a>, <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> &gt;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::variant&lt; <a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">edge_iterator</a>, <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> &gt;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a new edge with the given key into the graph before each given edge. </p>
<p>Each vertex argument can be either a vertex or an edge iterator. If it is a vertex, the edge will be inserted before the first edge in the given direction. If it is an edge, the new edge will be inserted before the given edge, and the vertex will be taken from the same endpoint.</p>
<p>The <code>before_outgoing</code> edge provides the source vertex for the new edge, and the <code>before_incoming</code> edge provides the target vertex.</p>
<p>If the graph has edge values, the new edge will be constructed in-place with the given arguments. </p>

</div>
</div>
<a id="ae29a7a394d70eddeb2b8ab4696530091" name="ae29a7a394d70eddeb2b8ab4696530091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae29a7a394d70eddeb2b8ab4696530091">&#9670;&#160;</a></span>emplace_directed_edge_before() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertKey , typename VertVal , typename EdgeKey , typename EdgeVal , template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; <br />
requires (not HasVertKey())</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>, bool &gt; <a class="el" href="structgraph_1_1_digraph_map.html">graph::DigraphMap</a>&lt; VertKey, VertVal, EdgeKey, EdgeVal, Map &gt;::emplace_directed_edge_before </td>
          <td>(</td>
          <td class="paramtype">std::variant&lt; <a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">edge_iterator</a>, <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> &gt;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::variant&lt; <a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">edge_iterator</a>, <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> &gt;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert an un-keyed edge at a specific place in the edge sequence. </p>
<p>The arguments are the same as for <code><a class="el" href="structgraph_1_1_digraph_map.html#a3a2a23b0a71f6aae2b55bc46b5a8dd1b" title="Insert a new edge with the given key into the graph before each given edge.">emplace_directed_edge_before()</a></code>, except that the <code>new_key</code> argument is omitted.</p>
<p>Not available if <code>HasEdgeKey() == true</code>. </p>

</div>
</div>
<a id="ada345428a50d8e94fbf6a1df879d7548" name="ada345428a50d8e94fbf6a1df879d7548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada345428a50d8e94fbf6a1df879d7548">&#9670;&#160;</a></span>emplace_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertKey , typename VertVal , typename EdgeKey , typename EdgeVal , template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; <br />
requires (HasVertKey() and HasVertexValue())</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>, bool &gt; <a class="el" href="structgraph_1_1_digraph_map.html">graph::DigraphMap</a>&lt; VertKey, VertVal, EdgeKey, EdgeVal, Map &gt;::emplace_vertex </td>
          <td>(</td>
          <td class="paramtype">const VertKey &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emplaces a vertex with the given key and value construction arguments into the graph. </p>
<p>Returns a pair of an iterator to the vertex with the given key, and a boolean indicating whether the vertex was inserted (<code>true</code>) or already existed (<code>false</code>).</p>
<p>In the case where the vertex was inserted, the value is constructed in-place from the given arguments. Otherwise, the value is left unchanged. </p>

</div>
</div>
<a id="abc3899584e92bfcc6d8f782c9311ec18" name="abc3899584e92bfcc6d8f782c9311ec18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc3899584e92bfcc6d8f782c9311ec18">&#9670;&#160;</a></span>erase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertKey , typename VertVal , typename EdgeKey , typename EdgeVal , template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; EdgeVal &gt; <a class="el" href="structgraph_1_1_digraph_map.html">graph::DigraphMap</a>&lt; VertKey, VertVal, EdgeKey, EdgeVal, Map &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const EdgeKey &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the edge with the given key from the graph, if present. </p>
<p>Returns the value associated with the deleted edge, or <code>std::nullopt</code> if the edge was not present in the graph. </p>

</div>
</div>
<a id="a523087655f421ac9f15b90473bee924f" name="a523087655f421ac9f15b90473bee924f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a523087655f421ac9f15b90473bee924f">&#9670;&#160;</a></span>erase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertKey , typename VertVal , typename EdgeKey , typename EdgeVal , template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="structgraph_1_1_digraph_map.html">graph::DigraphMap</a>&lt; VertKey, VertVal, EdgeKey, EdgeVal, Map &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const EdgeKey &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the edge with the given key from the graph, if present. </p>
<p>Returns the number of edges (0 or 1) removed from the graph. </p>

</div>
</div>
<a id="a0527acc39fdda480a70dcbf704561851" name="a0527acc39fdda480a70dcbf704561851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0527acc39fdda480a70dcbf704561851">&#9670;&#160;</a></span>erase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertKey , typename VertVal , typename EdgeKey , typename EdgeVal , template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="structgraph_1_1_digraph_map.html">graph::DigraphMap</a>&lt; VertKey, VertVal, EdgeKey, EdgeVal, Map &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const VertKey &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the vertex with the given key from the graph, if present. </p>
<p>This operation is <code>O(degree(v))</code>, where <code>v</code> is the vertex indexed by <code>key</code>.</p>
<p>Returns the number of vertices (0 or 1) removed from the graph. </p>

</div>
</div>
<a id="a91d6ec1e440386100c4d6b45ac8d3f2c" name="a91d6ec1e440386100c4d6b45ac8d3f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91d6ec1e440386100c4d6b45ac8d3f2c">&#9670;&#160;</a></span>find_edge() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertKey , typename VertVal , typename EdgeKey , typename EdgeVal , template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">edge_iterator</a> <a class="el" href="structgraph_1_1_digraph_map.html">graph::DigraphMap</a>&lt; VertKey, VertVal, EdgeKey, EdgeVal, Map &gt;::find_edge </td>
          <td>(</td>
          <td class="paramtype">const EdgeKey &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the edge with the given key. </p>
<p>If the key is not present in the graph, returns <code>this-&gt;<a class="el" href="structgraph_1_1_digraph.html#af246167edd4ec5c4bac29f81969f4b2b" title="A sentinel iterator pointing beyond the end of the range of edges.">end_edges()</a></code>. </p>

</div>
</div>
<a id="a5cb586e07f97607424b008498df8397d" name="a5cb586e07f97607424b008498df8397d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cb586e07f97607424b008498df8397d">&#9670;&#160;</a></span>find_edge() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertKey , typename VertVal , typename EdgeKey , typename EdgeVal , template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">const_edge_iterator</a> <a class="el" href="structgraph_1_1_digraph_map.html">graph::DigraphMap</a>&lt; VertKey, VertVal, EdgeKey, EdgeVal, Map &gt;::find_edge </td>
          <td>(</td>
          <td class="paramtype">const EdgeKey &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator to the edge with the given key. </p>
<p>If the key is not present in the graph, returns <code>this-&gt;<a class="el" href="structgraph_1_1_digraph.html#af246167edd4ec5c4bac29f81969f4b2b" title="A sentinel iterator pointing beyond the end of the range of edges.">end_edges()</a></code>. </p>

</div>
</div>
<a id="ae805ed41f16480845c0b8c080d89fb7b" name="ae805ed41f16480845c0b8c080d89fb7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae805ed41f16480845c0b8c080d89fb7b">&#9670;&#160;</a></span>find_edge() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertKey , typename VertVal , typename EdgeKey , typename EdgeVal , template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a> <a class="el" href="structgraph_1_1_digraph.html">graph::Digraph</a>&lt; V, E, Map &gt;::find_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">const_vertex_iterator</a>&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">const_vertex_iterator</a>&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the edge connecting the two given vertices. </p>
<p>If no such edge exists, end_incident_edges(v0, EdgeDir::Outgoing) will be returned.</p>
<p>If either vertex iterator is invalid, an iterator that compares equal to other end edge iterators will be returned. (This iterator cannot be decremented).</p>
<p>This operation is O(k), with k being the degree of the smaller vertex.</p>
<p>The direction of the iterator will be such that it is traversing the vertex with smaller degree. </p>

</div>
</div>
<a id="af7e8e34c1ddde1c701fb1f5320775c7e" name="af7e8e34c1ddde1c701fb1f5320775c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e8e34c1ddde1c701fb1f5320775c7e">&#9670;&#160;</a></span>find_edge() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertKey , typename VertVal , typename EdgeKey , typename EdgeVal , template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">const_incident_edge_iterator</a> <a class="el" href="structgraph_1_1_digraph.html">graph::Digraph</a>&lt; V, E, Map &gt;::find_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">const_vertex_iterator</a>&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">const_vertex_iterator</a>&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the edge connecting the two given vertices. </p>
<p>If no such edge exists, end_incident_edges(v0, EdgeDir::OUTGOING) will be returned.</p>
<p>If either vertex iterator is invalid, an iterator that compares equal to other end edge iterators will be returned. (This iterator cannot be decremented).</p>
<p>This operation is O(k), with k being the degree of the smaller vertex.</p>
<p>The direction of the iterator will be such that it is traversing the vertex with smaller degree. </p>

</div>
</div>
<a id="aa51033fff8c4dcab66007bec179c2e50" name="aa51033fff8c4dcab66007bec179c2e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa51033fff8c4dcab66007bec179c2e50">&#9670;&#160;</a></span>find_edge() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertKey , typename VertVal , typename EdgeKey , typename EdgeVal , template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a> <a class="el" href="structgraph_1_1_digraph.html">graph::Digraph</a>&lt; V, E, Map &gt;::find_edge </td>
          <td>(</td>
          <td class="paramtype">EdgeId&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeDir&#160;</td>
          <td class="paramname"><em>dir</em> = <code>EdgeDir::Outgoing</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator pointing to the vertex with the given id. </p>
<p><code>dir</code> determines the direction of the iterator. </p>

</div>
</div>
<a id="a72d6728dca23fc72667089d763fe953b" name="a72d6728dca23fc72667089d763fe953b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72d6728dca23fc72667089d763fe953b">&#9670;&#160;</a></span>find_edge() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertKey , typename VertVal , typename EdgeKey , typename EdgeVal , template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">const_incident_edge_iterator</a> <a class="el" href="structgraph_1_1_digraph.html">graph::Digraph</a>&lt; V, E, Map &gt;::find_edge </td>
          <td>(</td>
          <td class="paramtype">EdgeId&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeDir&#160;</td>
          <td class="paramname"><em>dir</em> = <code>EdgeDir::Outgoing</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const iterator pointing to the vertex with the given id. </p>
<p><code>dir</code> determines the direction of the iterator. </p>

</div>
</div>
<a id="a9f57037d24892bf7ec4d881f9f7925d5" name="a9f57037d24892bf7ec4d881f9f7925d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f57037d24892bf7ec4d881f9f7925d5">&#9670;&#160;</a></span>find_vertex() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertKey , typename VertVal , typename EdgeKey , typename EdgeVal , template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> <a class="el" href="structgraph_1_1_digraph_map.html">graph::DigraphMap</a>&lt; VertKey, VertVal, EdgeKey, EdgeVal, Map &gt;::find_vertex </td>
          <td>(</td>
          <td class="paramtype">const VertKey &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the vertex with the given key. </p>
<p>If the key is not present in the graph, returns <code>this-&gt;<a class="el" href="structgraph_1_1_digraph.html#a29fc6bcdf6b17be31c43ca6fac346754" title="A sentinel iterator pointing beyond the end of the range of vertices.">end_vertices()</a></code>. </p>

</div>
</div>
<a id="a7dde2cb54cfc31f9bc9dcca0453bf7d9" name="a7dde2cb54cfc31f9bc9dcca0453bf7d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dde2cb54cfc31f9bc9dcca0453bf7d9">&#9670;&#160;</a></span>find_vertex() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertKey , typename VertVal , typename EdgeKey , typename EdgeVal , template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">const_vertex_iterator</a> <a class="el" href="structgraph_1_1_digraph_map.html">graph::DigraphMap</a>&lt; VertKey, VertVal, EdgeKey, EdgeVal, Map &gt;::find_vertex </td>
          <td>(</td>
          <td class="paramtype">const VertKey &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const iterator to the vertex with the given key. </p>
<p>If the key is not present in the graph, returns <code>this-&gt;<a class="el" href="structgraph_1_1_digraph.html#a29fc6bcdf6b17be31c43ca6fac346754" title="A sentinel iterator pointing beyond the end of the range of vertices.">end_vertices()</a></code>. </p>

</div>
</div>
<a id="a7bdd6d25f2ef79bc80d4f18a97cb8a00" name="a7bdd6d25f2ef79bc80d4f18a97cb8a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bdd6d25f2ef79bc80d4f18a97cb8a00">&#9670;&#160;</a></span>find_vertex() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertKey , typename VertVal , typename EdgeKey , typename EdgeVal , template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> <a class="el" href="structgraph_1_1_digraph.html">graph::Digraph</a>&lt; V, E, Map &gt;::find_vertex </td>
          <td>(</td>
          <td class="paramtype">VertexId&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the vertex with the given id and return a mutable iterator to it. </p>
<p>If the vertex does not exist, <a class="el" href="structgraph_1_1_digraph.html#a29fc6bcdf6b17be31c43ca6fac346754" title="A sentinel iterator pointing beyond the end of the range of vertices.">end_vertices()</a> will be returned. </p>

</div>
</div>
<a id="a2083cc486407e88f43afc54010dc1cf1" name="a2083cc486407e88f43afc54010dc1cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2083cc486407e88f43afc54010dc1cf1">&#9670;&#160;</a></span>find_vertex() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertKey , typename VertVal , typename EdgeKey , typename EdgeVal , template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">const_vertex_iterator</a> <a class="el" href="structgraph_1_1_digraph.html">graph::Digraph</a>&lt; V, E, Map &gt;::find_vertex </td>
          <td>(</td>
          <td class="paramtype">VertexId&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the vertex with the given id and return a const iterator to it. </p>
<p>If the vertex does not exist, <a class="el" href="structgraph_1_1_digraph.html#a29fc6bcdf6b17be31c43ca6fac346754" title="A sentinel iterator pointing beyond the end of the range of vertices.">end_vertices()</a> will be returned. </p>

</div>
</div>
<a id="aedf48fefe379fcc852865dfdc6bf8a14" name="aedf48fefe379fcc852865dfdc6bf8a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedf48fefe379fcc852865dfdc6bf8a14">&#9670;&#160;</a></span>insert_or_assign_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertKey , typename VertVal , typename EdgeKey , typename EdgeVal , template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<div class="memtemplate">
template&lt;Forwardable&lt; VertVal &gt; T&gt; <br />
requires (HasVertKey() and HasVertexValue())</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>, bool &gt; <a class="el" href="structgraph_1_1_digraph_map.html">graph::DigraphMap</a>&lt; VertKey, VertVal, EdgeKey, EdgeVal, Map &gt;::insert_or_assign_vertex </td>
          <td>(</td>
          <td class="paramtype">const VertKey &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a vertex with the given key and value into the graph. </p>
<p>Returns a pair of an iterator to the vertex with the given key, and a boolean indicating whether the vertex was inserted (<code>true</code>) or already existed (<code>false</code>). </p>

</div>
</div>
<a id="ac27ac0f031564032199e2b8702e54a9b" name="ac27ac0f031564032199e2b8702e54a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac27ac0f031564032199e2b8702e54a9b">&#9670;&#160;</a></span>insert_vertex() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertKey , typename VertVal , typename EdgeKey , typename EdgeVal , template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>, bool &gt; <a class="el" href="structgraph_1_1_digraph_map.html">graph::DigraphMap</a>&lt; VertKey, VertVal, EdgeKey, EdgeVal, Map &gt;::insert_vertex </td>
          <td>(</td>
          <td class="paramtype">const VertKey &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a vertex with the given key into the graph. </p>
<p>Returns a pair of an iterator to the vertex with the given key, and a boolean indicating whether the vertex was inserted (<code>true</code>) or already existed (<code>false</code>).</p>
<p>In the case where the vertex was inserted, the value is default-constructed. Otherwise, the value is left unchanged. </p>

</div>
</div>
<a id="a8790d76a9bb598b8fa190d422f4cd01d" name="a8790d76a9bb598b8fa190d422f4cd01d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8790d76a9bb598b8fa190d422f4cd01d">&#9670;&#160;</a></span>insert_vertex() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertKey , typename VertVal , typename EdgeKey , typename EdgeVal , template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<div class="memtemplate">
template&lt;Forwardable&lt; VertVal &gt; T&gt; <br />
requires (HasVertKey() and HasVertexValue())</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>, bool &gt; <a class="el" href="structgraph_1_1_digraph_map.html">graph::DigraphMap</a>&lt; VertKey, VertVal, EdgeKey, EdgeVal, Map &gt;::insert_vertex </td>
          <td>(</td>
          <td class="paramtype">const VertKey &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a vertex with the given key and value into the graph. </p>
<p>Returns a pair of an iterator to the vertex with the given key, and a boolean indicating whether the vertex was inserted (<code>true</code>) or already existed (<code>false</code>).</p>
<p>In the case where the vertex was inserted, the value is copy-constructed from the given value. Otherwise, the value is left unchanged. </p>

</div>
</div>
<a id="a0b0c4e18c3ae0ddb040eb3f32bbd447e" name="a0b0c4e18c3ae0ddb040eb3f32bbd447e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b0c4e18c3ae0ddb040eb3f32bbd447e">&#9670;&#160;</a></span>insert_vertex() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertKey , typename VertVal , typename EdgeKey , typename EdgeVal , template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<div class="memtemplate">
template&lt;Forwardable&lt; VertVal &gt; T&gt; <br />
requires (not HasVertKey() and HasVertexValue())</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> <a class="el" href="structgraph_1_1_digraph_map.html">graph::DigraphMap</a>&lt; VertKey, VertVal, EdgeKey, EdgeVal, Map &gt;::insert_vertex </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a vertex with the given value into the graph. </p>
<p>Returns an iterator to the new vertex. </p>

</div>
</div>
<a id="a518c5c74898607db589dd06771783dd6" name="a518c5c74898607db589dd06771783dd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a518c5c74898607db589dd06771783dd6">&#9670;&#160;</a></span>key_for() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertKey , typename VertVal , typename EdgeKey , typename EdgeVal , template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const EdgeKey &amp; <a class="el" href="structgraph_1_1_digraph_map.html">graph::DigraphMap</a>&lt; VertKey, VertVal, EdgeKey, EdgeVal, Map &gt;::key_for </td>
          <td>(</td>
          <td class="paramtype">EdgeId&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the key for the edge with the given Id. </p>
<p>Throws <code>std::out_of_range</code> if the edge is not in the graph. </p>

</div>
</div>
<a id="a3fdc45156388185a02feac132d74c1f1" name="a3fdc45156388185a02feac132d74c1f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fdc45156388185a02feac132d74c1f1">&#9670;&#160;</a></span>key_for() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertKey , typename VertVal , typename EdgeKey , typename EdgeVal , template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const VertKey &amp; <a class="el" href="structgraph_1_1_digraph_map.html">graph::DigraphMap</a>&lt; VertKey, VertVal, EdgeKey, EdgeVal, Map &gt;::key_for </td>
          <td>(</td>
          <td class="paramtype">VertexId&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the key for the vertex with the given Id. </p>
<p>Throws <code>std::out_of_range</code> if the vertex is not in the graph. </p>

</div>
</div>
<a id="aca82b75251516cc0eb79e45b9151da63" name="aca82b75251516cc0eb79e45b9151da63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca82b75251516cc0eb79e45b9151da63">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertKey , typename VertVal , typename EdgeKey , typename EdgeVal , template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_edge_ref.html">edge_ref</a> <a class="el" href="structgraph_1_1_digraph_map.html">graph::DigraphMap</a>&lt; VertKey, VertVal, EdgeKey, EdgeVal, Map &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const EdgeKey &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the edge with the given key. </p>
<p>If the key is not present in the graph, a <code>std::out_of_range</code> exception is thrown. </p>

</div>
</div>
<a id="a56e5459342f2d747a6af42fbdd5114dc" name="a56e5459342f2d747a6af42fbdd5114dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56e5459342f2d747a6af42fbdd5114dc">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertKey , typename VertVal , typename EdgeKey , typename EdgeVal , template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_edge_ref.html">const_edge_ref</a> <a class="el" href="structgraph_1_1_digraph_map.html">graph::DigraphMap</a>&lt; VertKey, VertVal, EdgeKey, EdgeVal, Map &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const EdgeKey &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reference to the edge with the given key. </p>
<p>If the key is not present in the graph, a <code>std::out_of_range</code> exception is thrown. </p>

</div>
</div>
<a id="acb2530573805615e994757ae920e1d54" name="acb2530573805615e994757ae920e1d54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb2530573805615e994757ae920e1d54">&#9670;&#160;</a></span>operator[]() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertKey , typename VertVal , typename EdgeKey , typename EdgeVal , template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_ref.html">vertex_ref</a> <a class="el" href="structgraph_1_1_digraph_map.html">graph::DigraphMap</a>&lt; VertKey, VertVal, EdgeKey, EdgeVal, Map &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const VertKey &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the vertex with the given key. </p>
<p>If the key is not present in the graph, a new vertex is created with the given key and a reference to it is returned. </p>

</div>
</div>
<a id="a99a9050535e715622bdfbb1b3f103232" name="a99a9050535e715622bdfbb1b3f103232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99a9050535e715622bdfbb1b3f103232">&#9670;&#160;</a></span>operator[]() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertKey , typename VertVal , typename EdgeKey , typename EdgeVal , template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_ref.html">const_vertex_ref</a> <a class="el" href="structgraph_1_1_digraph_map.html">graph::DigraphMap</a>&lt; VertKey, VertVal, EdgeKey, EdgeVal, Map &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const VertKey &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a const reference to the vertex with the given key. </p>
<p>If the key is not present in the graph, a <code>std::out_of_range</code> exception is thrown. </p>

</div>
</div>
<a id="a05ab7ad32fdcfa5e920b76d303775d1e" name="a05ab7ad32fdcfa5e920b76d303775d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ab7ad32fdcfa5e920b76d303775d1e">&#9670;&#160;</a></span>redirect_edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertKey , typename VertVal , typename EdgeKey , typename EdgeVal , template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; <br />
requires (HasEdgeKey())</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">edge_iterator</a>, EdgeChange &gt; <a class="el" href="structgraph_1_1_digraph_map.html">graph::DigraphMap</a>&lt; VertKey, VertVal, EdgeKey, EdgeVal, Map &gt;::redirect_edge </td>
          <td>(</td>
          <td class="paramtype">const EdgeKey &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Associate the edge key with a directed edge between the given vertices. </p>
<p>If an edge with the given key already exists, replace it, and construct its associated value from the given arguments.</p>
<p>If no such edge exists, emplace one using the given arguments.</p>
<p>Return an iterator to the edge, and a bool indicating whether the edge was inserted (true) or existed already (false).</p>
<p>To prefer keeping the previous edge value in the case where it exists, use <code><a class="el" href="structgraph_1_1_digraph_map.html#a12d02212774529a2d8c66dd058119abf" title="Change the endpoints of the edge with the given key, preserving the edge&#39;s value if one exists.">try_redirect_edge()</a></code>.</p>
<p>If the edge endpoints were changed, the EdgeId associated with the key will change as well. </p>

</div>
</div>
<a id="a12d02212774529a2d8c66dd058119abf" name="a12d02212774529a2d8c66dd058119abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12d02212774529a2d8c66dd058119abf">&#9670;&#160;</a></span>try_redirect_edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertKey , typename VertVal , typename EdgeKey , typename EdgeVal , template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; <br />
requires (HasEdgeKey() and HasEdgeValue())</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>, bool &gt; <a class="el" href="structgraph_1_1_digraph_map.html">graph::DigraphMap</a>&lt; VertKey, VertVal, EdgeKey, EdgeVal, Map &gt;::try_redirect_edge </td>
          <td>(</td>
          <td class="paramtype">const EdgeKey &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the endpoints of the edge with the given key, preserving the edge's value if one exists. </p>
<p>If the edge does not exist, insert one having a value constructed from the given arguments.</p>
<p>If the edge does exist, it will be redirected, and the existing value will be preserved.</p>
<p>To unconditionally replace the existing value, use <code><a class="el" href="structgraph_1_1_digraph_map.html#a05ab7ad32fdcfa5e920b76d303775d1e" title="Associate the edge key with a directed edge between the given vertices.">redirect_edge()</a></code>.</p>
<p>If the edge endpoints were changed, the EdgeId associated with the key will change as well.</p>
<p>If this graph does not contain edge values, this function is equivalent to <code><a class="el" href="structgraph_1_1_digraph_map.html#a05ab7ad32fdcfa5e920b76d303775d1e" title="Associate the edge key with a directed edge between the given vertices.">redirect_edge()</a></code>, and is therefore not available. </p>

</div>
</div>
<a id="a5820206eaab128abb7ce31bdac4a51fb" name="a5820206eaab128abb7ce31bdac4a51fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5820206eaab128abb7ce31bdac4a51fb">&#9670;&#160;</a></span>vertex() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertKey , typename VertVal , typename EdgeKey , typename EdgeVal , template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="structgraph_1_1_digraph_1_1_vertex_ref.html">const_vertex_ref</a> &gt; <a class="el" href="structgraph_1_1_digraph_map.html">graph::DigraphMap</a>&lt; VertKey, VertVal, EdgeKey, EdgeVal, Map &gt;::vertex </td>
          <td>(</td>
          <td class="paramtype">const VertKey &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a const reference to the vertex with the given key, or <code>std::nullopt</code> if not found. </p>

</div>
</div>
<a id="a291b3fcfc3dce1e8a0bf00489c66c4be" name="a291b3fcfc3dce1e8a0bf00489c66c4be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a291b3fcfc3dce1e8a0bf00489c66c4be">&#9670;&#160;</a></span>vertex() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertKey , typename VertVal , typename EdgeKey , typename EdgeVal , template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="structgraph_1_1_digraph_1_1_vertex_ref.html">vertex_ref</a> &gt; <a class="el" href="structgraph_1_1_digraph.html">graph::Digraph</a>&lt; V, E, Map &gt;::vertex </td>
          <td>(</td>
          <td class="paramtype">VertexId&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the vertex with the given id, if it exists. </p>
<p>If the vertex does not exist, std::nullopt will be returned. </p>

</div>
</div>
<a id="af6f560df464a4c711f6182e3f344a064" name="af6f560df464a4c711f6182e3f344a064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f560df464a4c711f6182e3f344a064">&#9670;&#160;</a></span>vertex() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VertKey , typename VertVal , typename EdgeKey , typename EdgeVal , template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="structgraph_1_1_digraph_1_1_vertex_ref.html">const_vertex_ref</a> &gt; <a class="el" href="structgraph_1_1_digraph.html">graph::Digraph</a>&lt; V, E, Map &gt;::vertex </td>
          <td>(</td>
          <td class="paramtype">VertexId&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reference to the vertex with the given id, if it exists. </p>
<p>If the vertex does not exist, std::nullopt will be returned. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>graph/<a class="el" href="digraph_8h_source.html">digraph.h</a></li>
<li>graph/<a class="el" href="digraph__map_8h_source.html">digraph_map.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
