<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>graph: graph::Digraph&lt; V, E, Map &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">graph
   </div>
   <div id="projectbrief">A simple, header-only C++ directed graph library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>graph</b></li><li class="navelem"><a class="el" href="structgraph_1_1_digraph.html">Digraph</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="structgraph_1_1_digraph-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">graph::Digraph&lt; V, E, Map &gt; Struct Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A class representing a directed graph.  
 <a href="structgraph_1_1_digraph.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="digraph_8h_source.html">digraph.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for graph::Digraph&lt; V, E, Map &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="structgraph_1_1_digraph.png" usemap="#graph::Digraph_3C_20V_2C_20E_2C_20Map_20_3E_map" alt=""/>
  <map id="graph::Digraph_3C_20V_2C_20E_2C_20Map_20_3E_map" name="graph::Digraph_3C_20V_2C_20E_2C_20Map_20_3E_map">
<area href="structgraph_1_1_digraph_map.html" title="A digraph class that allows vertices and/or edges to be indexed by a custom type in O(1) time." alt="graph::DigraphMap&lt; VertKey, VertVal, EdgeKey, EdgeVal, Map &gt;" shape="rect" coords="0,56,394,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">EdgeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator over all the edges in a graph.  <a href="structgraph_1_1_digraph_1_1_edge_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_1_1_edge_pair.html">EdgePair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_1_1_edge_range.html">EdgeRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A range capturing all the edges in a graph.  <a href="structgraph_1_1_digraph_1_1_edge_range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_1_1_edge_ref.html">EdgeRef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">IncidentEdgeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator over the edges incident to a vertex.  <a href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_range.html">IncidentEdgeRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A range capturing all the edges incident to a vertex in a given direction.  <a href="structgraph_1_1_digraph_1_1_incident_edge_range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">VertexIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator over the vertices in a graph.  <a href="structgraph_1_1_digraph_1_1_vertex_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_range.html">VertexRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A range capturing all the edges in a graph.  <a href="structgraph_1_1_digraph_1_1_vertex_range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_ref.html">VertexRef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7e1adadbe5507bb6883c1a222b42e6fd"><td class="memItemLeft" align="right" valign="top"><a id="a7e1adadbe5507bb6883c1a222b42e6fd" name="a7e1adadbe5507bb6883c1a222b42e6fd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>vertex_iterator</b> = <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">VertexIterator</a>&lt; Constness::Mutable &gt;</td></tr>
<tr class="separator:a7e1adadbe5507bb6883c1a222b42e6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c1f69a8162fb57ed1a67ddfe1d61a3"><td class="memItemLeft" align="right" valign="top"><a id="ab4c1f69a8162fb57ed1a67ddfe1d61a3" name="ab4c1f69a8162fb57ed1a67ddfe1d61a3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_vertex_iterator</b> = <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">VertexIterator</a>&lt; Constness::Const &gt;</td></tr>
<tr class="separator:ab4c1f69a8162fb57ed1a67ddfe1d61a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fcf928b1091dfd6a7b38ce3767fcaaa"><td class="memItemLeft" align="right" valign="top"><a id="a8fcf928b1091dfd6a7b38ce3767fcaaa" name="a8fcf928b1091dfd6a7b38ce3767fcaaa"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>edge_iterator</b> = <a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">EdgeIterator</a>&lt; Constness::Mutable &gt;</td></tr>
<tr class="separator:a8fcf928b1091dfd6a7b38ce3767fcaaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe168f294b8bcbfac4681350771beb83"><td class="memItemLeft" align="right" valign="top"><a id="abe168f294b8bcbfac4681350771beb83" name="abe168f294b8bcbfac4681350771beb83"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_edge_iterator</b> = <a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">EdgeIterator</a>&lt; Constness::Const &gt;</td></tr>
<tr class="separator:abe168f294b8bcbfac4681350771beb83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a502601c837cd50a57475d7170c0dfad1"><td class="memItemLeft" align="right" valign="top"><a id="a502601c837cd50a57475d7170c0dfad1" name="a502601c837cd50a57475d7170c0dfad1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>incident_edge_iterator</b> = <a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">IncidentEdgeIterator</a>&lt; Constness::Mutable &gt;</td></tr>
<tr class="separator:a502601c837cd50a57475d7170c0dfad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96e6fa371b27a1e6599f5389e19b8a0"><td class="memItemLeft" align="right" valign="top"><a id="ac96e6fa371b27a1e6599f5389e19b8a0" name="ac96e6fa371b27a1e6599f5389e19b8a0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_incident_edge_iterator</b> = <a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">IncidentEdgeIterator</a>&lt; Constness::Const &gt;</td></tr>
<tr class="separator:ac96e6fa371b27a1e6599f5389e19b8a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7544512439f6b7d32b8117f8716469a0"><td class="memItemLeft" align="right" valign="top"><a id="a7544512439f6b7d32b8117f8716469a0" name="a7544512439f6b7d32b8117f8716469a0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>vertex_range</b> = <a class="el" href="structgraph_1_1_digraph_1_1_vertex_range.html">VertexRange</a>&lt; Constness::Mutable &gt;</td></tr>
<tr class="separator:a7544512439f6b7d32b8117f8716469a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c85c6c68327a7fa2c44401373394734"><td class="memItemLeft" align="right" valign="top"><a id="a4c85c6c68327a7fa2c44401373394734" name="a4c85c6c68327a7fa2c44401373394734"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_vertex_range</b> = <a class="el" href="structgraph_1_1_digraph_1_1_vertex_range.html">VertexRange</a>&lt; Constness::Const &gt;</td></tr>
<tr class="separator:a4c85c6c68327a7fa2c44401373394734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af000f14c0cc10487971110555684246d"><td class="memItemLeft" align="right" valign="top"><a id="af000f14c0cc10487971110555684246d" name="af000f14c0cc10487971110555684246d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>edge_range</b> = <a class="el" href="structgraph_1_1_digraph_1_1_edge_range.html">EdgeRange</a>&lt; Constness::Mutable &gt;</td></tr>
<tr class="separator:af000f14c0cc10487971110555684246d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6724bca2ecc2f4f0d04fbf74dbb88bc7"><td class="memItemLeft" align="right" valign="top"><a id="a6724bca2ecc2f4f0d04fbf74dbb88bc7" name="a6724bca2ecc2f4f0d04fbf74dbb88bc7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_edge_range</b> = <a class="el" href="structgraph_1_1_digraph_1_1_edge_range.html">EdgeRange</a>&lt; Constness::Const &gt;</td></tr>
<tr class="separator:a6724bca2ecc2f4f0d04fbf74dbb88bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ac2dc037a7130aea427e86bd3fb0bc"><td class="memItemLeft" align="right" valign="top"><a id="a88ac2dc037a7130aea427e86bd3fb0bc" name="a88ac2dc037a7130aea427e86bd3fb0bc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>incident_edge_range</b> = <a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_range.html">IncidentEdgeRange</a>&lt; Constness::Mutable &gt;</td></tr>
<tr class="separator:a88ac2dc037a7130aea427e86bd3fb0bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616b4f18681cd5da578c121c4bd7d189"><td class="memItemLeft" align="right" valign="top"><a id="a616b4f18681cd5da578c121c4bd7d189" name="a616b4f18681cd5da578c121c4bd7d189"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_incident_edge_range</b> = <a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_range.html">IncidentEdgeRange</a>&lt; Constness::Const &gt;</td></tr>
<tr class="separator:a616b4f18681cd5da578c121c4bd7d189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4539705f7b79273ea3681f7f8bf6b1"><td class="memItemLeft" align="right" valign="top"><a id="a4e4539705f7b79273ea3681f7f8bf6b1" name="a4e4539705f7b79273ea3681f7f8bf6b1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>vertex_ref</b> = <a class="el" href="structgraph_1_1_digraph_1_1_vertex_ref.html">VertexRef</a>&lt; Constness::Mutable &gt;</td></tr>
<tr class="separator:a4e4539705f7b79273ea3681f7f8bf6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930b150bd3641193d94d88045726a11f"><td class="memItemLeft" align="right" valign="top"><a id="a930b150bd3641193d94d88045726a11f" name="a930b150bd3641193d94d88045726a11f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_vertex_ref</b> = <a class="el" href="structgraph_1_1_digraph_1_1_vertex_ref.html">VertexRef</a>&lt; Constness::Const &gt;</td></tr>
<tr class="separator:a930b150bd3641193d94d88045726a11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12fb580792550f7ae911bc808e94a256"><td class="memItemLeft" align="right" valign="top"><a id="a12fb580792550f7ae911bc808e94a256" name="a12fb580792550f7ae911bc808e94a256"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>edge_ref</b> = <a class="el" href="structgraph_1_1_digraph_1_1_edge_ref.html">EdgeRef</a>&lt; Constness::Mutable &gt;</td></tr>
<tr class="separator:a12fb580792550f7ae911bc808e94a256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985959e1242e88857f3d47a5cf8c2f35"><td class="memItemLeft" align="right" valign="top"><a id="a985959e1242e88857f3d47a5cf8c2f35" name="a985959e1242e88857f3d47a5cf8c2f35"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_edge_ref</b> = <a class="el" href="structgraph_1_1_digraph_1_1_edge_ref.html">EdgeRef</a>&lt; Constness::Const &gt;</td></tr>
<tr class="separator:a985959e1242e88857f3d47a5cf8c2f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afc76c059d8c510e7ddd115d386c45e72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_ref.html">const_vertex_ref</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#afc76c059d8c510e7ddd115d386c45e72">operator[]</a> (VertexId v) const</td></tr>
<tr class="memdesc:afc76c059d8c510e7ddd115d386c45e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a const reference to the vertex with the given id.  <br /></td></tr>
<tr class="separator:afc76c059d8c510e7ddd115d386c45e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8204ccba579f1f814836f1479b126b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_ref.html">vertex_ref</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#af8204ccba579f1f814836f1479b126b1">operator[]</a> (VertexId v)</td></tr>
<tr class="memdesc:af8204ccba579f1f814836f1479b126b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a reference to the vertex with the given id.  <br /></td></tr>
<tr class="separator:af8204ccba579f1f814836f1479b126b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573685de7e8d6324f90e3f02ecf61bea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_edge_ref.html">const_edge_ref</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#a573685de7e8d6324f90e3f02ecf61bea">operator[]</a> (EdgeId e) const</td></tr>
<tr class="memdesc:a573685de7e8d6324f90e3f02ecf61bea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a const reference to the edge with the given id.  <br /></td></tr>
<tr class="separator:a573685de7e8d6324f90e3f02ecf61bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8a238f097f3c7665a12fff755dd95f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_edge_ref.html">edge_ref</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#ac8a238f097f3c7665a12fff755dd95f3">operator[]</a> (EdgeId e)</td></tr>
<tr class="memdesc:ac8a238f097f3c7665a12fff755dd95f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a reference to the edge with the given id.  <br /></td></tr>
<tr class="separator:ac8a238f097f3c7665a12fff755dd95f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ffa3bdc586e66bd90b92fdeb3176d3"><td class="memItemLeft" align="right" valign="top"><a id="a04ffa3bdc586e66bd90b92fdeb3176d3" name="a04ffa3bdc586e66bd90b92fdeb3176d3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>contains</b> (VertexId vid) const</td></tr>
<tr class="memdesc:a04ffa3bdc586e66bd90b92fdeb3176d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the graph contains a vertex with the given id. <br /></td></tr>
<tr class="separator:a04ffa3bdc586e66bd90b92fdeb3176d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b12879230ce2ebb30363c4de8a29808"><td class="memItemLeft" align="right" valign="top"><a id="a1b12879230ce2ebb30363c4de8a29808" name="a1b12879230ce2ebb30363c4de8a29808"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>contains</b> (EdgeId eid) const</td></tr>
<tr class="memdesc:a1b12879230ce2ebb30363c4de8a29808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the graph contains an edge with the given id. <br /></td></tr>
<tr class="separator:a1b12879230ce2ebb30363c4de8a29808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Vertex modifiers</div></td></tr>
<tr class="memitem:af052c89504e5ef4f121410647d7ac865"><td class="memItemLeft" align="right" valign="top"><a id="af052c89504e5ef4f121410647d7ac865" name="af052c89504e5ef4f121410647d7ac865"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert_vertex</b> ()</td></tr>
<tr class="memdesc:af052c89504e5ef4f121410647d7ac865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new vertex into the graph, and return an iterator to it. <br /></td></tr>
<tr class="separator:af052c89504e5ef4f121410647d7ac865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c766be3a5d8e65ce72bd811482d37f"><td class="memTemplParams" colspan="2">template&lt;Forwardable&lt; V &gt; T&gt; <br />
requires (HasVertexValue())</td></tr>
<tr class="memitem:a72c766be3a5d8e65ce72bd811482d37f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#a72c766be3a5d8e65ce72bd811482d37f">insert_vertex</a> (T &amp;&amp;v)</td></tr>
<tr class="separator:a72c766be3a5d8e65ce72bd811482d37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a308f3ed01474186bf8f37f822a3f57d3"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; <br />
requires (HasVertexValue())</td></tr>
<tr class="memitem:a308f3ed01474186bf8f37f822a3f57d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#a308f3ed01474186bf8f37f822a3f57d3">emplace_vertex</a> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:a308f3ed01474186bf8f37f822a3f57d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e04e2f0d5a38577b3ca3ca5640322a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#a11e04e2f0d5a38577b3ca3ca5640322a">erase</a> (<a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> v)</td></tr>
<tr class="memdesc:a11e04e2f0d5a38577b3ca3ca5640322a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the given vertex, and return an iterator to the following vertex.  <br /></td></tr>
<tr class="separator:a11e04e2f0d5a38577b3ca3ca5640322a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c6a7d8c1e8358a6dac4c04103332ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#a54c6a7d8c1e8358a6dac4c04103332ff">erase</a> (VertexId vid)</td></tr>
<tr class="memdesc:a54c6a7d8c1e8358a6dac4c04103332ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the vertex with the given ID, and return an iterator to the following vertex.  <br /></td></tr>
<tr class="separator:a54c6a7d8c1e8358a6dac4c04103332ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Vertex iteration</div></td></tr>
<tr class="memitem:a62d66bc2cc6099934368b859cd12ea0a"><td class="memItemLeft" align="right" valign="top"><a id="a62d66bc2cc6099934368b859cd12ea0a" name="a62d66bc2cc6099934368b859cd12ea0a"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_vertex_range.html">VertexRange</a>&lt; Constness::Mutable &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>vertices</b> ()</td></tr>
<tr class="memdesc:a62d66bc2cc6099934368b859cd12ea0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A range of all the vertices in the graph. <br /></td></tr>
<tr class="separator:a62d66bc2cc6099934368b859cd12ea0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cfc2534b42a9e77169361c22c8f1f42"><td class="memItemLeft" align="right" valign="top"><a id="a1cfc2534b42a9e77169361c22c8f1f42" name="a1cfc2534b42a9e77169361c22c8f1f42"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_vertex_range.html">VertexRange</a>&lt; Constness::Const &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>vertices</b> () const</td></tr>
<tr class="memdesc:a1cfc2534b42a9e77169361c22c8f1f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">An immutable range of all the vertices in the graph. <br /></td></tr>
<tr class="separator:a1cfc2534b42a9e77169361c22c8f1f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13290ba8d07cc281487e09328c6dc803"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#a13290ba8d07cc281487e09328c6dc803">begin_vertices</a> ()</td></tr>
<tr class="memdesc:a13290ba8d07cc281487e09328c6dc803"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator pointing to the first vertex in the graph.  <br /></td></tr>
<tr class="separator:a13290ba8d07cc281487e09328c6dc803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29fc6bcdf6b17be31c43ca6fac346754"><td class="memItemLeft" align="right" valign="top"><a id="a29fc6bcdf6b17be31c43ca6fac346754" name="a29fc6bcdf6b17be31c43ca6fac346754"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end_vertices</b> ()</td></tr>
<tr class="memdesc:a29fc6bcdf6b17be31c43ca6fac346754"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sentinel iterator pointing beyond the end of the range of vertices. <br /></td></tr>
<tr class="separator:a29fc6bcdf6b17be31c43ca6fac346754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8b671c032c844c02fd2fd2f8056ccb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">const_vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#a9c8b671c032c844c02fd2fd2f8056ccb">begin_vertices</a> () const</td></tr>
<tr class="memdesc:a9c8b671c032c844c02fd2fd2f8056ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const iterator pointing to the first vertex in the graph.  <br /></td></tr>
<tr class="separator:a9c8b671c032c844c02fd2fd2f8056ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec9d19219f488e7c15f8b5b06c1b6dd"><td class="memItemLeft" align="right" valign="top"><a id="afec9d19219f488e7c15f8b5b06c1b6dd" name="afec9d19219f488e7c15f8b5b06c1b6dd"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">const_vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end_vertices</b> () const</td></tr>
<tr class="memdesc:afec9d19219f488e7c15f8b5b06c1b6dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const sentinel iterator pointing beyond the end of the range of vertices. <br /></td></tr>
<tr class="separator:afec9d19219f488e7c15f8b5b06c1b6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7794317dca2c5b157ecb20b4194638f6"><td class="memItemLeft" align="right" valign="top"><a id="a7794317dca2c5b157ecb20b4194638f6" name="a7794317dca2c5b157ecb20b4194638f6"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">const_vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin_vertices</b> () const</td></tr>
<tr class="separator:a7794317dca2c5b157ecb20b4194638f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab981dca5d3858d6fd8bd0ae136734b23"><td class="memItemLeft" align="right" valign="top"><a id="ab981dca5d3858d6fd8bd0ae136734b23" name="ab981dca5d3858d6fd8bd0ae136734b23"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">const_vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cend_vertices</b> () const</td></tr>
<tr class="separator:ab981dca5d3858d6fd8bd0ae136734b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9121bd6cd3bdf2657400943acc4b4314"><td class="memItemLeft" align="right" valign="top"><a id="a9121bd6cd3bdf2657400943acc4b4314" name="a9121bd6cd3bdf2657400943acc4b4314"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>vertices_size</b> () const</td></tr>
<tr class="memdesc:a9121bd6cd3bdf2657400943acc4b4314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of vertices in the graph. <br /></td></tr>
<tr class="separator:a9121bd6cd3bdf2657400943acc4b4314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Edge iteration</div></td></tr>
<tr class="memitem:a208d46dcca7fa0f4fadc42720efa10f6"><td class="memItemLeft" align="right" valign="top"><a id="a208d46dcca7fa0f4fadc42720efa10f6" name="a208d46dcca7fa0f4fadc42720efa10f6"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_edge_range.html">EdgeRange</a>&lt; Constness::Mutable &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>edges</b> ()</td></tr>
<tr class="memdesc:a208d46dcca7fa0f4fadc42720efa10f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A range of all the edges in the graph. <br /></td></tr>
<tr class="separator:a208d46dcca7fa0f4fadc42720efa10f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7211a982588e79a0025bcd2996997d59"><td class="memItemLeft" align="right" valign="top"><a id="a7211a982588e79a0025bcd2996997d59" name="a7211a982588e79a0025bcd2996997d59"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_edge_range.html">EdgeRange</a>&lt; Constness::Const &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>edges</b> () const</td></tr>
<tr class="memdesc:a7211a982588e79a0025bcd2996997d59"><td class="mdescLeft">&#160;</td><td class="mdescRight">An immutable range of all the edges in the graph. <br /></td></tr>
<tr class="separator:a7211a982588e79a0025bcd2996997d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178df2c954b82cb9c94db2fc6b6cad00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#a178df2c954b82cb9c94db2fc6b6cad00">begin_edges</a> ()</td></tr>
<tr class="memdesc:a178df2c954b82cb9c94db2fc6b6cad00"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator pointing to the first edge in the graph.  <br /></td></tr>
<tr class="separator:a178df2c954b82cb9c94db2fc6b6cad00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af246167edd4ec5c4bac29f81969f4b2b"><td class="memItemLeft" align="right" valign="top"><a id="af246167edd4ec5c4bac29f81969f4b2b" name="af246167edd4ec5c4bac29f81969f4b2b"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end_edges</b> ()</td></tr>
<tr class="memdesc:af246167edd4ec5c4bac29f81969f4b2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sentinel iterator pointing beyond the end of the range of edges. <br /></td></tr>
<tr class="separator:af246167edd4ec5c4bac29f81969f4b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42854027cafca6577d5c1230857a5a0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">const_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#a42854027cafca6577d5c1230857a5a0e">begin_edges</a> () const</td></tr>
<tr class="memdesc:a42854027cafca6577d5c1230857a5a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const iterator pointing to the first edge in the graph.  <br /></td></tr>
<tr class="separator:a42854027cafca6577d5c1230857a5a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae3eb784540e7abc4d391ef670a17dea"><td class="memItemLeft" align="right" valign="top"><a id="aae3eb784540e7abc4d391ef670a17dea" name="aae3eb784540e7abc4d391ef670a17dea"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">const_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end_edges</b> () const</td></tr>
<tr class="memdesc:aae3eb784540e7abc4d391ef670a17dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">A const sentinel iterator pointing beyond the end of the range of edges. <br /></td></tr>
<tr class="separator:aae3eb784540e7abc4d391ef670a17dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62036a949a11e641a53bbb2b1c8a0b51"><td class="memItemLeft" align="right" valign="top"><a id="a62036a949a11e641a53bbb2b1c8a0b51" name="a62036a949a11e641a53bbb2b1c8a0b51"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>edges_size</b> () const</td></tr>
<tr class="memdesc:a62036a949a11e641a53bbb2b1c8a0b51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of edges in the graph. <br /></td></tr>
<tr class="separator:a62036a949a11e641a53bbb2b1c8a0b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Vertex access</div></td></tr>
<tr class="memitem:a7bdd6d25f2ef79bc80d4f18a97cb8a00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#a7bdd6d25f2ef79bc80d4f18a97cb8a00">find_vertex</a> (VertexId v)</td></tr>
<tr class="memdesc:a7bdd6d25f2ef79bc80d4f18a97cb8a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the vertex with the given id and return a mutable iterator to it.  <br /></td></tr>
<tr class="separator:a7bdd6d25f2ef79bc80d4f18a97cb8a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2083cc486407e88f43afc54010dc1cf1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">const_vertex_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#a2083cc486407e88f43afc54010dc1cf1">find_vertex</a> (VertexId v) const</td></tr>
<tr class="memdesc:a2083cc486407e88f43afc54010dc1cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the vertex with the given id and return a const iterator to it.  <br /></td></tr>
<tr class="separator:a2083cc486407e88f43afc54010dc1cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a291b3fcfc3dce1e8a0bf00489c66c4be"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structgraph_1_1_digraph_1_1_vertex_ref.html">vertex_ref</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#a291b3fcfc3dce1e8a0bf00489c66c4be">vertex</a> (VertexId v)</td></tr>
<tr class="memdesc:a291b3fcfc3dce1e8a0bf00489c66c4be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the vertex with the given id, if it exists.  <br /></td></tr>
<tr class="separator:a291b3fcfc3dce1e8a0bf00489c66c4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f560df464a4c711f6182e3f344a064"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="structgraph_1_1_digraph_1_1_vertex_ref.html">const_vertex_ref</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#af6f560df464a4c711f6182e3f344a064">vertex</a> (VertexId v) const</td></tr>
<tr class="memdesc:af6f560df464a4c711f6182e3f344a064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the vertex with the given id, if it exists.  <br /></td></tr>
<tr class="separator:af6f560df464a4c711f6182e3f344a064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Incident edge iteration</div></td></tr>
<tr class="memitem:a1412d78dea33431034af24655489b275"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_range.html">IncidentEdgeRange</a>&lt; Constness::Mutable &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#a1412d78dea33431034af24655489b275">incident_edges</a> (VertexId v, EdgeDir dir=EdgeDir::Outgoing)</td></tr>
<tr class="memdesc:a1412d78dea33431034af24655489b275"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a range of edges which traverses all the edges incident to <code>v</code> in the given direction.  <br /></td></tr>
<tr class="separator:a1412d78dea33431034af24655489b275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319c9e8ee9680933c7d35f30f7f86ec3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_range.html">IncidentEdgeRange</a>&lt; Constness::Const &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#a319c9e8ee9680933c7d35f30f7f86ec3">incident_edges</a> (VertexId v, EdgeDir dir=EdgeDir::Outgoing) const</td></tr>
<tr class="memdesc:a319c9e8ee9680933c7d35f30f7f86ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a range of immuatble edges which traverses all the edges incident to <code>v</code> in the given direction.  <br /></td></tr>
<tr class="separator:a319c9e8ee9680933c7d35f30f7f86ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0c8b94611a1e5ed4a5fceffabc4367"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#aec0c8b94611a1e5ed4a5fceffabc4367">begin_incident_edges</a> (<a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> v, EdgeDir dir)</td></tr>
<tr class="memdesc:aec0c8b94611a1e5ed4a5fceffabc4367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator pointing to the first edge incident to <code>v</code> in the given direction.  <br /></td></tr>
<tr class="separator:aec0c8b94611a1e5ed4a5fceffabc4367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e719835402104804e4d28366f3f8ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">const_incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#a74e719835402104804e4d28366f3f8ce">begin_incident_edges</a> (<a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> v, EdgeDir dir) const</td></tr>
<tr class="memdesc:a74e719835402104804e4d28366f3f8ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const iterator pointing to the first edge incident to <code>v</code> in the given direction.  <br /></td></tr>
<tr class="separator:a74e719835402104804e4d28366f3f8ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abffa05252d8cad2593b5001e622e6d5e"><td class="memItemLeft" align="right" valign="top"><a id="abffa05252d8cad2593b5001e622e6d5e" name="abffa05252d8cad2593b5001e622e6d5e"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin_incident_edges</b> (VertexId v, EdgeDir dir)</td></tr>
<tr class="memdesc:abffa05252d8cad2593b5001e622e6d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>begin_incident_edges(find_vertex(v), dir)</code>. <br /></td></tr>
<tr class="separator:abffa05252d8cad2593b5001e622e6d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688ddbb552213a9dca3b475512c754b6"><td class="memItemLeft" align="right" valign="top"><a id="a688ddbb552213a9dca3b475512c754b6" name="a688ddbb552213a9dca3b475512c754b6"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">const_incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin_incident_edges</b> (VertexId v, EdgeDir dir) const</td></tr>
<tr class="memdesc:a688ddbb552213a9dca3b475512c754b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>begin_incident_edges(find_vertex(v), dir)</code>. <br /></td></tr>
<tr class="separator:a688ddbb552213a9dca3b475512c754b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9667ab957346eb20e3abdee7ae51bd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#aa9667ab957346eb20e3abdee7ae51bd8">end_incident_edges</a> ()</td></tr>
<tr class="memdesc:aa9667ab957346eb20e3abdee7ae51bd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sentinel iterator indicating an empty incident edge range.  <br /></td></tr>
<tr class="separator:aa9667ab957346eb20e3abdee7ae51bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fecfb88d8359c66c042529c1ebdf8af"><td class="memItemLeft" align="right" valign="top"><a id="a6fecfb88d8359c66c042529c1ebdf8af" name="a6fecfb88d8359c66c042529c1ebdf8af"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">const_incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end_incident_edges</b> () const</td></tr>
<tr class="separator:a6fecfb88d8359c66c042529c1ebdf8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b83ce9d1bc446da311feecc621e266"><td class="memItemLeft" align="right" valign="top"><a id="a89b83ce9d1bc446da311feecc621e266" name="a89b83ce9d1bc446da311feecc621e266"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">const_incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin_incident_edges</b> (VertexId v, EdgeDir dir) const</td></tr>
<tr class="separator:a89b83ce9d1bc446da311feecc621e266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4276b1d50856e4a61c73daa056807f7"><td class="memItemLeft" align="right" valign="top"><a id="ad4276b1d50856e4a61c73daa056807f7" name="ad4276b1d50856e4a61c73daa056807f7"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">const_incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cend_incident_edges</b> () const</td></tr>
<tr class="separator:ad4276b1d50856e4a61c73daa056807f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Edge access</div></td></tr>
<tr class="memitem:aa51033fff8c4dcab66007bec179c2e50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#aa51033fff8c4dcab66007bec179c2e50">find_edge</a> (EdgeId e, EdgeDir dir=EdgeDir::Outgoing)</td></tr>
<tr class="memdesc:aa51033fff8c4dcab66007bec179c2e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator pointing to the vertex with the given id.  <br /></td></tr>
<tr class="separator:aa51033fff8c4dcab66007bec179c2e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d6728dca23fc72667089d763fe953b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">const_incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#a72d6728dca23fc72667089d763fe953b">find_edge</a> (EdgeId e, EdgeDir dir=EdgeDir::Outgoing) const</td></tr>
<tr class="memdesc:a72d6728dca23fc72667089d763fe953b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const iterator pointing to the vertex with the given id.  <br /></td></tr>
<tr class="separator:a72d6728dca23fc72667089d763fe953b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae805ed41f16480845c0b8c080d89fb7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#ae805ed41f16480845c0b8c080d89fb7b">find_edge</a> (<a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">const_vertex_iterator</a> v0, <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">const_vertex_iterator</a> v1)</td></tr>
<tr class="memdesc:ae805ed41f16480845c0b8c080d89fb7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the edge connecting the two given vertices.  <br /></td></tr>
<tr class="separator:ae805ed41f16480845c0b8c080d89fb7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa170b72190d6a1bee2189fc14015a5bc"><td class="memItemLeft" align="right" valign="top"><a id="aa170b72190d6a1bee2189fc14015a5bc" name="aa170b72190d6a1bee2189fc14015a5bc"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>find_edge</b> (<a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> v0, <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> v1)</td></tr>
<tr class="separator:aa170b72190d6a1bee2189fc14015a5bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e8e34c1ddde1c701fb1f5320775c7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">const_incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#af7e8e34c1ddde1c701fb1f5320775c7e">find_edge</a> (<a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">const_vertex_iterator</a> v0, <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">const_vertex_iterator</a> v1) const</td></tr>
<tr class="memdesc:af7e8e34c1ddde1c701fb1f5320775c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the edge connecting the two given vertices.  <br /></td></tr>
<tr class="separator:af7e8e34c1ddde1c701fb1f5320775c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672dc9fa3b145759db6bfa8bb1b891d6"><td class="memItemLeft" align="right" valign="top"><a id="a672dc9fa3b145759db6bfa8bb1b891d6" name="a672dc9fa3b145759db6bfa8bb1b891d6"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>find_edge</b> (VertexId v0, VertexId v1)</td></tr>
<tr class="memdesc:a672dc9fa3b145759db6bfa8bb1b891d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>find_edge(find_vertex(v0), find_vertex(v1))</code>. <br /></td></tr>
<tr class="separator:a672dc9fa3b145759db6bfa8bb1b891d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c55b2e7fe82a49fcde3ca05a121c707"><td class="memItemLeft" align="right" valign="top"><a id="a9c55b2e7fe82a49fcde3ca05a121c707" name="a9c55b2e7fe82a49fcde3ca05a121c707"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">const_incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>find_edge</b> (VertexId v0, VertexId v1) const</td></tr>
<tr class="memdesc:a9c55b2e7fe82a49fcde3ca05a121c707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>find_edge(find_vertex(v0), find_vertex(v1))</code>. <br /></td></tr>
<tr class="separator:a9c55b2e7fe82a49fcde3ca05a121c707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883da5c3b15937b7e53c49ff34e8434b"><td class="memItemLeft" align="right" valign="top"><a id="a883da5c3b15937b7e53c49ff34e8434b" name="a883da5c3b15937b7e53c49ff34e8434b"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>find_edge</b> (<a class="el" href="structgraph_1_1_edge.html">Edge</a> e)</td></tr>
<tr class="memdesc:a883da5c3b15937b7e53c49ff34e8434b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>find_edge(e.v0, e.v1)</code>. <br /></td></tr>
<tr class="separator:a883da5c3b15937b7e53c49ff34e8434b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9130f92722890203ce3e3f20c1d3950"><td class="memItemLeft" align="right" valign="top"><a id="aa9130f92722890203ce3e3f20c1d3950" name="aa9130f92722890203ce3e3f20c1d3950"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">const_incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>find_edge</b> (<a class="el" href="structgraph_1_1_edge.html">Edge</a> e) const</td></tr>
<tr class="memdesc:aa9130f92722890203ce3e3f20c1d3950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>find_edge(e.v0, e.v1)</code>. <br /></td></tr>
<tr class="separator:aa9130f92722890203ce3e3f20c1d3950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad383717d9f9dd6c07c6be47e6f0201e1"><td class="memItemLeft" align="right" valign="top"><a id="ad383717d9f9dd6c07c6be47e6f0201e1" name="ad383717d9f9dd6c07c6be47e6f0201e1"></a>
std::optional&lt; <a class="el" href="structgraph_1_1_digraph_1_1_edge_ref.html">edge_ref</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>edge</b> (EdgeId edge)</td></tr>
<tr class="memdesc:ad383717d9f9dd6c07c6be47e6f0201e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the edge with the given id. <br /></td></tr>
<tr class="separator:ad383717d9f9dd6c07c6be47e6f0201e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f10850e7edd1b74a7f4be8b2dee5b0e"><td class="memItemLeft" align="right" valign="top"><a id="a8f10850e7edd1b74a7f4be8b2dee5b0e" name="a8f10850e7edd1b74a7f4be8b2dee5b0e"></a>
std::optional&lt; <a class="el" href="structgraph_1_1_digraph_1_1_edge_ref.html">const_edge_ref</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>edge</b> (EdgeId edge) const</td></tr>
<tr class="memdesc:a8f10850e7edd1b74a7f4be8b2dee5b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the edge with the given id. <br /></td></tr>
<tr class="separator:a8f10850e7edd1b74a7f4be8b2dee5b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7530bb5563e1e0c83e19732182bc083a"><td class="memItemLeft" align="right" valign="top"><a id="a7530bb5563e1e0c83e19732182bc083a" name="a7530bb5563e1e0c83e19732182bc083a"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>HasVertexValue</b> ()</td></tr>
<tr class="separator:a7530bb5563e1e0c83e19732182bc083a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6826706590749b2c490020070be7fa36"><td class="memItemLeft" align="right" valign="top"><a id="a6826706590749b2c490020070be7fa36" name="a6826706590749b2c490020070be7fa36"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>HasEdgeValue</b> ()</td></tr>
<tr class="separator:a6826706590749b2c490020070be7fa36"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a3f5f04861e9fe4dbf9d24d988fb9b105"><td class="memTemplParams" colspan="2"><a id="a3f5f04861e9fe4dbf9d24d988fb9b105" name="a3f5f04861e9fe4dbf9d24d988fb9b105"></a>
template&lt;typename VertKey , typename VertVal , typename EdgeKey , typename EdgeVal , template&lt; class... &gt; class M&gt; </td></tr>
<tr class="memitem:a3f5f04861e9fe4dbf9d24d988fb9b105"><td class="memTemplItemLeft" align="right" valign="top">struct&#160;</td><td class="memTemplItemRight" valign="bottom"><b>DigraphMap</b></td></tr>
<tr class="separator:a3f5f04861e9fe4dbf9d24d988fb9b105"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Edge modifiers</h2></td></tr>
<tr class="memitem:a047c99700140d76912584824255a21b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#a047c99700140d76912584824255a21b9">insert_directed_edge</a> (<a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> src, <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> dst)</td></tr>
<tr class="memdesc:a047c99700140d76912584824255a21b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new edge into the graph connecting the two given vertices, and return an iterator to it.  <br /></td></tr>
<tr class="separator:a047c99700140d76912584824255a21b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc9f411cced006d473413b608383f39"><td class="memTemplParams" colspan="2">template&lt;Forwardable&lt; E &gt; T&gt; <br />
requires (HasEdgeValue())</td></tr>
<tr class="memitem:aedc9f411cced006d473413b608383f39"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#aedc9f411cced006d473413b608383f39">insert_directed_edge</a> (<a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> src, <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> dst, T &amp;&amp;e)</td></tr>
<tr class="memdesc:aedc9f411cced006d473413b608383f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new edge into the graph connecting the two given vertices, storing the given value, and return an iterator to it.  <br /></td></tr>
<tr class="separator:aedc9f411cced006d473413b608383f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2661b5974e81d8a0150292c3b409ff19"><td class="memItemLeft" align="right" valign="top"><a id="a2661b5974e81d8a0150292c3b409ff19" name="a2661b5974e81d8a0150292c3b409ff19"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert_directed_edge</b> (VertexId src, VertexId dst)</td></tr>
<tr class="memdesc:a2661b5974e81d8a0150292c3b409ff19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>insert_directed_edge(find_vertex(src), find_vertex(dst))</code>. <br /></td></tr>
<tr class="separator:a2661b5974e81d8a0150292c3b409ff19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66dd049e97547dd21cf1f593e8d58858"><td class="memTemplParams" colspan="2"><a id="a66dd049e97547dd21cf1f593e8d58858" name="a66dd049e97547dd21cf1f593e8d58858"></a>
template&lt;Forwardable&lt; E &gt; T&gt; <br />
requires (HasEdgeValue())</td></tr>
<tr class="memitem:a66dd049e97547dd21cf1f593e8d58858"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insert_directed_edge</b> (VertexId src, VertexId dst, T &amp;&amp;e)</td></tr>
<tr class="memdesc:a66dd049e97547dd21cf1f593e8d58858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <code>insert_directed_edge(find_vertex(src), find_vertex(dst), e)</code>. <br /></td></tr>
<tr class="separator:a66dd049e97547dd21cf1f593e8d58858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106798dd4433d287d473a7f1b3d9ca95"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a106798dd4433d287d473a7f1b3d9ca95"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#a106798dd4433d287d473a7f1b3d9ca95">emplace_directed_edge</a> (<a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> src, <a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> dst, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a106798dd4433d287d473a7f1b3d9ca95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new edge into the graph connecting the two given vertices, constructing a new edge value in-place with the given arguments, and return an iterator to it.  <br /></td></tr>
<tr class="separator:a106798dd4433d287d473a7f1b3d9ca95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af851493b2f6a927bab78662a8c9be090"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>, <a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#af851493b2f6a927bab78662a8c9be090">insert_undirected_edge</a> (VertexId a, VertexId b)</td></tr>
<tr class="memdesc:af851493b2f6a927bab78662a8c9be090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an undirected edge between the two given vertices by inserting two directed edges in opposing directions.  <br /></td></tr>
<tr class="separator:af851493b2f6a927bab78662a8c9be090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117266a0fcb2b72fad411377551b6524"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgraph_1_1_digraph_1_1_edge_pair.html">EdgePair</a>&lt; std::optional&lt; EdgeId &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgraph_1_1_digraph.html#a117266a0fcb2b72fad411377551b6524">erase</a> (<a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a> <a class="el" href="structgraph_1_1_digraph.html#ad383717d9f9dd6c07c6be47e6f0201e1">edge</a>)</td></tr>
<tr class="memdesc:a117266a0fcb2b72fad411377551b6524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the given edge, and return the IDs of edges that followed it in the incoming and outgoing edge sequences.  <br /></td></tr>
<tr class="separator:a117266a0fcb2b72fad411377551b6524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4afdacd5785fc87e4a93212545f7ee"><td class="memItemLeft" align="right" valign="top"><a id="a6d4afdacd5785fc87e4a93212545f7ee" name="a6d4afdacd5785fc87e4a93212545f7ee"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (<a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a> <a class="el" href="structgraph_1_1_digraph.html#ad383717d9f9dd6c07c6be47e6f0201e1">edge</a>, EdgeDir dir)</td></tr>
<tr class="memdesc:a6d4afdacd5785fc87e4a93212545f7ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the given edge, and return an iterator to the following edge in the given direction. <br /></td></tr>
<tr class="separator:a6d4afdacd5785fc87e4a93212545f7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b069fcdc9063498357ac8d029f9983"><td class="memItemLeft" align="right" valign="top"><a id="a82b069fcdc9063498357ac8d029f9983" name="a82b069fcdc9063498357ac8d029f9983"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (EdgeId eid)</td></tr>
<tr class="memdesc:a82b069fcdc9063498357ac8d029f9983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the edge with the given id, returning an iterator to the following edge in the graph. <br /></td></tr>
<tr class="separator:a82b069fcdc9063498357ac8d029f9983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3605392c9b72bcbd0bd7ad680a235953"><td class="memItemLeft" align="right" valign="top"><a id="a3605392c9b72bcbd0bd7ad680a235953" name="a3605392c9b72bcbd0bd7ad680a235953"></a>
<a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">edge_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>erase</b> (<a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">edge_iterator</a> <a class="el" href="structgraph_1_1_digraph.html#ad383717d9f9dd6c07c6be47e6f0201e1">edge</a>)</td></tr>
<tr class="memdesc:a3605392c9b72bcbd0bd7ad680a235953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the given edge, returning an iterator to the following edge in the graph. <br /></td></tr>
<tr class="separator:a3605392c9b72bcbd0bd7ad680a235953"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename V = void, typename E = void, template&lt; class... &gt; class Map = std::unordered_map&gt;<br />
struct graph::Digraph&lt; V, E, Map &gt;</div><p>A class representing a directed graph. </p>
<pre class="fragment">#include &lt;graph/digraph.h&gt;
</pre><p> Values may optionally be associated with either vertices or edges. If no value is to be stored, the type <code>void</code> may be used, and no storage will be allocated for that type.</p>
<p>The graph associates a unique ID with each vertex and edge. These IDs are unique to the graph container they belong to, are 64-bit, and are never re-used by the same container.</p>
<p>If you need to index edges or vertices by custom keys, use the <code><a class="el" href="structgraph_1_1_digraph_map.html" title="A digraph class that allows vertices and/or edges to be indexed by a custom type in O(1) time.">DigraphMap</a></code> class defined in <code>&lt;<a class="el" href="digraph__map_8h_source.html">graph/digraph_map.h</a>&gt;</code>.</p>
<p>Iterator invalidation follows the same rules as the underlying map type, since all iterators wrap the iterators of the underlying map.</p>
<p>Indexing by a valid iterator will generally be more performant than indexing by ID.</p>
<p>Indexing by ID will always be stable, regardless of mutations to other vertices and edges. Indexing by a disused ID will return the corresponding <code>end()</code> iterator.</p>
<p>Iterators to vertices are independent of iterators to edges; i.e. mutations to the set of edges will not invalidate vertex iterators. Additions to the set of vertices will not invalidate edge iterators; however, deletion of vertices will also delete all edges incident to that vertex, which in turn <em>may</em> invalidate edge iterators (depending on the iterator stability guarantees of the underlying map).</p>
<p>The graph is implemented as two maps from IDs to data: One for vertices, and one for edges. Edges belong to linked lists of edges incident to each vertex. An edge belongs to two such lists: One for incoming edges, and one for outgoing edges. The nodes in each list are connected by their stable IDs, and are sequenced in insertion order.</p>
<p>The type of map which stores vertices and edges may be passed as a template template parameter. The default map is <code>std::unordered_map</code>, but much better performance may be obtained by using a modern third-party hash map such as <code>absl::flat_hash_map</code> or <code>ankerl::unordered_dense::map</code>. The map parameter is a <b>template template</b> parameter, so you must pass the template name itself without any template arguments, like: <code><a class="el" href="structgraph_1_1_digraph.html" title="A class representing a directed graph.">Digraph</a>&lt;int, int, std::unordered_map&gt;</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V</td><td>Type associated with vertices (may be <code>void</code>). </td></tr>
    <tr><td class="paramname">E</td><td>Type associated with edges (may be <code>void</code>). </td></tr>
    <tr><td class="paramname">Map</td><td>Template class of an associative map type used to store the graph. Defaults to <code>std::unordered_map</code>. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a178df2c954b82cb9c94db2fc6b6cad00" name="a178df2c954b82cb9c94db2fc6b6cad00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a178df2c954b82cb9c94db2fc6b6cad00">&#9670;&#160;</a></span>begin_edges() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V  = void, typename E  = void, template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">edge_iterator</a> <a class="el" href="structgraph_1_1_digraph.html">graph::Digraph</a>&lt; V, E, Map &gt;::begin_edges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An iterator pointing to the first edge in the graph. </p>
<p>If the graph has no edges, this iterator will be equal to <a class="el" href="structgraph_1_1_digraph.html#af246167edd4ec5c4bac29f81969f4b2b" title="A sentinel iterator pointing beyond the end of the range of edges.">end_edges()</a>. </p>

</div>
</div>
<a id="a42854027cafca6577d5c1230857a5a0e" name="a42854027cafca6577d5c1230857a5a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42854027cafca6577d5c1230857a5a0e">&#9670;&#160;</a></span>begin_edges() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V  = void, typename E  = void, template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_edge_iterator.html">const_edge_iterator</a> <a class="el" href="structgraph_1_1_digraph.html">graph::Digraph</a>&lt; V, E, Map &gt;::begin_edges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A const iterator pointing to the first edge in the graph. </p>
<p>If the graph has no edges, this iterator will be equal to <a class="el" href="structgraph_1_1_digraph.html#af246167edd4ec5c4bac29f81969f4b2b" title="A sentinel iterator pointing beyond the end of the range of edges.">end_edges()</a>. </p>

</div>
</div>
<a id="aec0c8b94611a1e5ed4a5fceffabc4367" name="aec0c8b94611a1e5ed4a5fceffabc4367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec0c8b94611a1e5ed4a5fceffabc4367">&#9670;&#160;</a></span>begin_incident_edges() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V  = void, typename E  = void, template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a> <a class="el" href="structgraph_1_1_digraph.html">graph::Digraph</a>&lt; V, E, Map &gt;::begin_incident_edges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeDir&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator pointing to the first edge incident to <code>v</code> in the given direction. </p>
<p>This iterator will not traverse any edges in the opposite incidence direction (except for self-loop edges).</p>
<p>If the vertex has no edges in the given direction, <a class="el" href="structgraph_1_1_digraph.html#aa9667ab957346eb20e3abdee7ae51bd8" title="A sentinel iterator indicating an empty incident edge range.">end_incident_edges()</a> will be returned. </p>

</div>
</div>
<a id="a74e719835402104804e4d28366f3f8ce" name="a74e719835402104804e4d28366f3f8ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74e719835402104804e4d28366f3f8ce">&#9670;&#160;</a></span>begin_incident_edges() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V  = void, typename E  = void, template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">const_incident_edge_iterator</a> <a class="el" href="structgraph_1_1_digraph.html">graph::Digraph</a>&lt; V, E, Map &gt;::begin_incident_edges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeDir&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const iterator pointing to the first edge incident to <code>v</code> in the given direction. </p>
<p>This iterator will not traverse any edges in the opposite incidence direction (except for self-loop edges).</p>
<p>If the vertex has no edges in the given direction, <a class="el" href="structgraph_1_1_digraph.html#aa9667ab957346eb20e3abdee7ae51bd8" title="A sentinel iterator indicating an empty incident edge range.">end_incident_edges()</a> will be returned. </p>

</div>
</div>
<a id="a13290ba8d07cc281487e09328c6dc803" name="a13290ba8d07cc281487e09328c6dc803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13290ba8d07cc281487e09328c6dc803">&#9670;&#160;</a></span>begin_vertices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V  = void, typename E  = void, template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> <a class="el" href="structgraph_1_1_digraph.html">graph::Digraph</a>&lt; V, E, Map &gt;::begin_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An iterator pointing to the first vertex in the graph. </p>
<p>If the graph is empty, this iterator will be equal to <a class="el" href="structgraph_1_1_digraph.html#a29fc6bcdf6b17be31c43ca6fac346754" title="A sentinel iterator pointing beyond the end of the range of vertices.">end_vertices()</a>. </p>

</div>
</div>
<a id="a9c8b671c032c844c02fd2fd2f8056ccb" name="a9c8b671c032c844c02fd2fd2f8056ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c8b671c032c844c02fd2fd2f8056ccb">&#9670;&#160;</a></span>begin_vertices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V  = void, typename E  = void, template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">const_vertex_iterator</a> <a class="el" href="structgraph_1_1_digraph.html">graph::Digraph</a>&lt; V, E, Map &gt;::begin_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A const iterator pointing to the first vertex in the graph. </p>
<p>If the graph is empty, this iterator will be equal to <a class="el" href="structgraph_1_1_digraph.html#a29fc6bcdf6b17be31c43ca6fac346754" title="A sentinel iterator pointing beyond the end of the range of vertices.">end_vertices()</a>. </p>

</div>
</div>
<a id="a106798dd4433d287d473a7f1b3d9ca95" name="a106798dd4433d287d473a7f1b3d9ca95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a106798dd4433d287d473a7f1b3d9ca95">&#9670;&#160;</a></span>emplace_directed_edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V  = void, typename E  = void, template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a> <a class="el" href="structgraph_1_1_digraph.html">graph::Digraph</a>&lt; V, E, Map &gt;::emplace_directed_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a new edge into the graph connecting the two given vertices, constructing a new edge value in-place with the given arguments, and return an iterator to it. </p>
<p>Edges may be duplicated; a new edge will be created whether or not one between the two vertices already exists. </p>

</div>
</div>
<a id="a308f3ed01474186bf8f37f822a3f57d3" name="a308f3ed01474186bf8f37f822a3f57d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a308f3ed01474186bf8f37f822a3f57d3">&#9670;&#160;</a></span>emplace_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V  = void, typename E  = void, template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; <br />
requires (HasVertexValue())</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> <a class="el" href="structgraph_1_1_digraph.html">graph::Digraph</a>&lt; V, E, Map &gt;::emplace_vertex </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Insert a new vertex into the graph and construct it in-place with the given arguments, and return an iterator to it. </p>

</div>
</div>
<a id="aa9667ab957346eb20e3abdee7ae51bd8" name="aa9667ab957346eb20e3abdee7ae51bd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9667ab957346eb20e3abdee7ae51bd8">&#9670;&#160;</a></span>end_incident_edges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V  = void, typename E  = void, template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a> <a class="el" href="structgraph_1_1_digraph.html">graph::Digraph</a>&lt; V, E, Map &gt;::end_incident_edges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A sentinel iterator indicating an empty incident edge range. </p>
<p>This iterator is unreachable by incrementing a valid iterator. </p>

</div>
</div>
<a id="a117266a0fcb2b72fad411377551b6524" name="a117266a0fcb2b72fad411377551b6524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a117266a0fcb2b72fad411377551b6524">&#9670;&#160;</a></span>erase() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V  = void, typename E  = void, template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_edge_pair.html">EdgePair</a>&lt; std::optional&lt; EdgeId &gt; &gt; <a class="el" href="structgraph_1_1_digraph.html">graph::Digraph</a>&lt; V, E, Map &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the given edge, and return the IDs of edges that followed it in the incoming and outgoing edge sequences. </p>
<p>This is slightly more efficient than the overload of <a class="el" href="structgraph_1_1_digraph.html#a11e04e2f0d5a38577b3ca3ca5640322a" title="Remove the given vertex, and return an iterator to the following vertex.">erase()</a> which returns an incident_edge_iterator. </p>

</div>
</div>
<a id="a11e04e2f0d5a38577b3ca3ca5640322a" name="a11e04e2f0d5a38577b3ca3ca5640322a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11e04e2f0d5a38577b3ca3ca5640322a">&#9670;&#160;</a></span>erase() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V  = void, typename E  = void, template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> <a class="el" href="structgraph_1_1_digraph.html">graph::Digraph</a>&lt; V, E, Map &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the given vertex, and return an iterator to the following vertex. </p>
<p>This operation is <code>O(degree(v))</code>.</p>
<p>All edges incident to the vertex will also be removed. </p>

</div>
</div>
<a id="a54c6a7d8c1e8358a6dac4c04103332ff" name="a54c6a7d8c1e8358a6dac4c04103332ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54c6a7d8c1e8358a6dac4c04103332ff">&#9670;&#160;</a></span>erase() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V  = void, typename E  = void, template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> <a class="el" href="structgraph_1_1_digraph.html">graph::Digraph</a>&lt; V, E, Map &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">VertexId&#160;</td>
          <td class="paramname"><em>vid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the vertex with the given ID, and return an iterator to the following vertex. </p>
<p>Alias for <code>erase(find_vertex(vid))</code>. </p>

</div>
</div>
<a id="ae805ed41f16480845c0b8c080d89fb7b" name="ae805ed41f16480845c0b8c080d89fb7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae805ed41f16480845c0b8c080d89fb7b">&#9670;&#160;</a></span>find_edge() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V  = void, typename E  = void, template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a> <a class="el" href="structgraph_1_1_digraph.html">graph::Digraph</a>&lt; V, E, Map &gt;::find_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">const_vertex_iterator</a>&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">const_vertex_iterator</a>&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the edge connecting the two given vertices. </p>
<p>If no such edge exists, <a class="el" href="structgraph_1_1_digraph.html#aa9667ab957346eb20e3abdee7ae51bd8" title="A sentinel iterator indicating an empty incident edge range.">end_incident_edges()</a> will be returned.</p>
<p>This operation is O(k), with k being the degree of the smaller vertex.</p>
<p>The direction of the iterator will be such that it is traversing the vertex with smaller degree. </p>

</div>
</div>
<a id="af7e8e34c1ddde1c701fb1f5320775c7e" name="af7e8e34c1ddde1c701fb1f5320775c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e8e34c1ddde1c701fb1f5320775c7e">&#9670;&#160;</a></span>find_edge() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V  = void, typename E  = void, template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">const_incident_edge_iterator</a> <a class="el" href="structgraph_1_1_digraph.html">graph::Digraph</a>&lt; V, E, Map &gt;::find_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">const_vertex_iterator</a>&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">const_vertex_iterator</a>&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the edge connecting the two given vertices. </p>
<p>If no such edge exists, <a class="el" href="structgraph_1_1_digraph.html#aa9667ab957346eb20e3abdee7ae51bd8" title="A sentinel iterator indicating an empty incident edge range.">end_incident_edges()</a> will be returned.</p>
<p>This operation is O(k), with k being the degree of the smaller vertex.</p>
<p>The direction of the iterator will be such that it is traversing the vertex with smaller degree. </p>

</div>
</div>
<a id="aa51033fff8c4dcab66007bec179c2e50" name="aa51033fff8c4dcab66007bec179c2e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa51033fff8c4dcab66007bec179c2e50">&#9670;&#160;</a></span>find_edge() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V  = void, typename E  = void, template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a> <a class="el" href="structgraph_1_1_digraph.html">graph::Digraph</a>&lt; V, E, Map &gt;::find_edge </td>
          <td>(</td>
          <td class="paramtype">EdgeId&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeDir&#160;</td>
          <td class="paramname"><em>dir</em> = <code>EdgeDir::Outgoing</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator pointing to the vertex with the given id. </p>
<p><code>dir</code> determines the direction of the iterator. </p>

</div>
</div>
<a id="a72d6728dca23fc72667089d763fe953b" name="a72d6728dca23fc72667089d763fe953b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72d6728dca23fc72667089d763fe953b">&#9670;&#160;</a></span>find_edge() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V  = void, typename E  = void, template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">const_incident_edge_iterator</a> <a class="el" href="structgraph_1_1_digraph.html">graph::Digraph</a>&lt; V, E, Map &gt;::find_edge </td>
          <td>(</td>
          <td class="paramtype">EdgeId&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeDir&#160;</td>
          <td class="paramname"><em>dir</em> = <code>EdgeDir::Outgoing</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const iterator pointing to the vertex with the given id. </p>
<p><code>dir</code> determines the direction of the iterator. </p>

</div>
</div>
<a id="a7bdd6d25f2ef79bc80d4f18a97cb8a00" name="a7bdd6d25f2ef79bc80d4f18a97cb8a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bdd6d25f2ef79bc80d4f18a97cb8a00">&#9670;&#160;</a></span>find_vertex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V  = void, typename E  = void, template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> <a class="el" href="structgraph_1_1_digraph.html">graph::Digraph</a>&lt; V, E, Map &gt;::find_vertex </td>
          <td>(</td>
          <td class="paramtype">VertexId&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the vertex with the given id and return a mutable iterator to it. </p>
<p>If the vertex does not exist, <a class="el" href="structgraph_1_1_digraph.html#a29fc6bcdf6b17be31c43ca6fac346754" title="A sentinel iterator pointing beyond the end of the range of vertices.">end_vertices()</a> will be returned. </p>

</div>
</div>
<a id="a2083cc486407e88f43afc54010dc1cf1" name="a2083cc486407e88f43afc54010dc1cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2083cc486407e88f43afc54010dc1cf1">&#9670;&#160;</a></span>find_vertex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V  = void, typename E  = void, template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">const_vertex_iterator</a> <a class="el" href="structgraph_1_1_digraph.html">graph::Digraph</a>&lt; V, E, Map &gt;::find_vertex </td>
          <td>(</td>
          <td class="paramtype">VertexId&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the vertex with the given id and return a const iterator to it. </p>
<p>If the vertex does not exist, <a class="el" href="structgraph_1_1_digraph.html#a29fc6bcdf6b17be31c43ca6fac346754" title="A sentinel iterator pointing beyond the end of the range of vertices.">end_vertices()</a> will be returned. </p>

</div>
</div>
<a id="a1412d78dea33431034af24655489b275" name="a1412d78dea33431034af24655489b275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1412d78dea33431034af24655489b275">&#9670;&#160;</a></span>incident_edges() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V  = void, typename E  = void, template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_range.html">IncidentEdgeRange</a>&lt; Constness::Mutable &gt; <a class="el" href="structgraph_1_1_digraph.html">graph::Digraph</a>&lt; V, E, Map &gt;::incident_edges </td>
          <td>(</td>
          <td class="paramtype">VertexId&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeDir&#160;</td>
          <td class="paramname"><em>dir</em> = <code>EdgeDir::Outgoing</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a range of edges which traverses all the edges incident to <code>v</code> in the given direction. </p>
<p>This range does not traverse any edges in the opposite incidence direction (excepting self-loop edges).</p>
<p>If the vertex has no edges in the given direction, an empty range will be returned. </p>

</div>
</div>
<a id="a319c9e8ee9680933c7d35f30f7f86ec3" name="a319c9e8ee9680933c7d35f30f7f86ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a319c9e8ee9680933c7d35f30f7f86ec3">&#9670;&#160;</a></span>incident_edges() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V  = void, typename E  = void, template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_range.html">IncidentEdgeRange</a>&lt; Constness::Const &gt; <a class="el" href="structgraph_1_1_digraph.html">graph::Digraph</a>&lt; V, E, Map &gt;::incident_edges </td>
          <td>(</td>
          <td class="paramtype">VertexId&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EdgeDir&#160;</td>
          <td class="paramname"><em>dir</em> = <code>EdgeDir::Outgoing</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a range of immuatble edges which traverses all the edges incident to <code>v</code> in the given direction. </p>
<p>This range does not traverse any edges in the opposite incidence direction (excepting self-loop edges).</p>
<p>If the vertex has no edges in the given direction, an empty range will be returned. </p>

</div>
</div>
<a id="a047c99700140d76912584824255a21b9" name="a047c99700140d76912584824255a21b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a047c99700140d76912584824255a21b9">&#9670;&#160;</a></span>insert_directed_edge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V  = void, typename E  = void, template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a> <a class="el" href="structgraph_1_1_digraph.html">graph::Digraph</a>&lt; V, E, Map &gt;::insert_directed_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a new edge into the graph connecting the two given vertices, and return an iterator to it. </p>
<p>Edges may be duplicated; a new edge will be created whether or not one between the two vertices already exists. </p>

</div>
</div>
<a id="aedc9f411cced006d473413b608383f39" name="aedc9f411cced006d473413b608383f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc9f411cced006d473413b608383f39">&#9670;&#160;</a></span>insert_directed_edge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V  = void, typename E  = void, template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<div class="memtemplate">
template&lt;Forwardable&lt; E &gt; T&gt; <br />
requires (HasEdgeValue())</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a> <a class="el" href="structgraph_1_1_digraph.html">graph::Digraph</a>&lt; V, E, Map &gt;::insert_directed_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a new edge into the graph connecting the two given vertices, storing the given value, and return an iterator to it. </p>
<p>Edges may be duplicated; a new edge will be created whether or not one between the two vertices already exists. </p>

</div>
</div>
<a id="af851493b2f6a927bab78662a8c9be090" name="af851493b2f6a927bab78662a8c9be090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af851493b2f6a927bab78662a8c9be090">&#9670;&#160;</a></span>insert_undirected_edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V  = void, typename E  = void, template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a>, <a class="el" href="structgraph_1_1_digraph_1_1_incident_edge_iterator.html">incident_edge_iterator</a> &gt; <a class="el" href="structgraph_1_1_digraph.html">graph::Digraph</a>&lt; V, E, Map &gt;::insert_undirected_edge </td>
          <td>(</td>
          <td class="paramtype">VertexId&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VertexId&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert an undirected edge between the two given vertices by inserting two directed edges in opposing directions. </p>
<p>Return a pair of iterators to the two edges. </p>

</div>
</div>
<a id="a72c766be3a5d8e65ce72bd811482d37f" name="a72c766be3a5d8e65ce72bd811482d37f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72c766be3a5d8e65ce72bd811482d37f">&#9670;&#160;</a></span>insert_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V  = void, typename E  = void, template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<div class="memtemplate">
template&lt;Forwardable&lt; V &gt; T&gt; <br />
requires (HasVertexValue())</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_iterator.html">vertex_iterator</a> <a class="el" href="structgraph_1_1_digraph.html">graph::Digraph</a>&lt; V, E, Map &gt;::insert_vertex </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Insert a new vertex into the graph storing the given value, and return an iterator to it. </p>

</div>
</div>
<a id="ac8a238f097f3c7665a12fff755dd95f3" name="ac8a238f097f3c7665a12fff755dd95f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8a238f097f3c7665a12fff755dd95f3">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V  = void, typename E  = void, template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_edge_ref.html">edge_ref</a> <a class="el" href="structgraph_1_1_digraph.html">graph::Digraph</a>&lt; V, E, Map &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">EdgeId&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a reference to the edge with the given id. </p>
<p>If the edge does not exist, <code>std::out_of_range</code> will be thrown. </p>

</div>
</div>
<a id="a573685de7e8d6324f90e3f02ecf61bea" name="a573685de7e8d6324f90e3f02ecf61bea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a573685de7e8d6324f90e3f02ecf61bea">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V  = void, typename E  = void, template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_edge_ref.html">const_edge_ref</a> <a class="el" href="structgraph_1_1_digraph.html">graph::Digraph</a>&lt; V, E, Map &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">EdgeId&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a const reference to the edge with the given id. </p>
<p>If the edge does not exist, <code>std::out_of_range</code> will be thrown. </p>

</div>
</div>
<a id="af8204ccba579f1f814836f1479b126b1" name="af8204ccba579f1f814836f1479b126b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8204ccba579f1f814836f1479b126b1">&#9670;&#160;</a></span>operator[]() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V  = void, typename E  = void, template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_ref.html">vertex_ref</a> <a class="el" href="structgraph_1_1_digraph.html">graph::Digraph</a>&lt; V, E, Map &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">VertexId&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a reference to the vertex with the given id. </p>
<p>If the vertex does not exist, it will be created. </p>

</div>
</div>
<a id="afc76c059d8c510e7ddd115d386c45e72" name="afc76c059d8c510e7ddd115d386c45e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc76c059d8c510e7ddd115d386c45e72">&#9670;&#160;</a></span>operator[]() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V  = void, typename E  = void, template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgraph_1_1_digraph_1_1_vertex_ref.html">const_vertex_ref</a> <a class="el" href="structgraph_1_1_digraph.html">graph::Digraph</a>&lt; V, E, Map &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">VertexId&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve a const reference to the vertex with the given id. </p>
<p>If the vertex does not exist, <code>std::out_of_range</code> will be thrown. </p>

</div>
</div>
<a id="a291b3fcfc3dce1e8a0bf00489c66c4be" name="a291b3fcfc3dce1e8a0bf00489c66c4be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a291b3fcfc3dce1e8a0bf00489c66c4be">&#9670;&#160;</a></span>vertex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V  = void, typename E  = void, template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="structgraph_1_1_digraph_1_1_vertex_ref.html">vertex_ref</a> &gt; <a class="el" href="structgraph_1_1_digraph.html">graph::Digraph</a>&lt; V, E, Map &gt;::vertex </td>
          <td>(</td>
          <td class="paramtype">VertexId&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to the vertex with the given id, if it exists. </p>
<p>If the vertex does not exist, std::nullopt will be returned. </p>

</div>
</div>
<a id="af6f560df464a4c711f6182e3f344a064" name="af6f560df464a4c711f6182e3f344a064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f560df464a4c711f6182e3f344a064">&#9670;&#160;</a></span>vertex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V  = void, typename E  = void, template&lt; class... &gt; class Map = std::unordered_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="structgraph_1_1_digraph_1_1_vertex_ref.html">const_vertex_ref</a> &gt; <a class="el" href="structgraph_1_1_digraph.html">graph::Digraph</a>&lt; V, E, Map &gt;::vertex </td>
          <td>(</td>
          <td class="paramtype">VertexId&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reference to the vertex with the given id, if it exists. </p>
<p>If the vertex does not exist, std::nullopt will be returned. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>graph/<a class="el" href="digraph_8h_source.html">digraph.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
